# Архитектура MVP GEO для локального сообщества  
**Вариант B: Community‑hub + лёгкие клиенты**

> Примечание: это **концептуальный документ** (исторический контекст по архитектурным вариантам и выборам стека).
>
> **Канонический стек текущей реализации в этом репозитории** зафиксирован в [`docs/ru/03-architecture.md`](docs/ru/03-architecture.md:1) (раздел «Технологический стек») и в манифестах зависимостей: `requirements.txt`, `requirements-dev.txt`, `admin-ui/package.json`.
>
> Упоминания ниже про TypeScript/NestJS/React и др. следует читать как **альтернативы, которые сейчас считаются устаревшими** для кода GEOv0.

Документ описывает архитектуру минимально жизнеспособного продукта (MVP) системы GEO для **одного локального сообщества** с возможностью эволюции:

- к **кластеру узлов** внутри сообщества;
- к **взаиморасчётам между несколькими сообществами** (cluster‑to‑cluster).

Цель — дать достаточно подробное описание компонентов, данных, протоколов и рекомендуемого стека, чтобы на его основе можно было спланировать и реализовать рабочий прототип.

---

## 1. Цели и рамки MVP

### 1.1. Цели

- Реализовать **экономику взаимного кредита** внутри одного локального сообщества (10–500 участников):
  - линии доверия между участниками;
  - операции «купил в кредит»;
  - автоматический поиск и запуск простых циклов клиринга (3–4 узла, базово).
- Обеспечить **удобный UX**:
  - web‑клиент (desktop/mobile browser);
  - по возможности — мобильное приложение на основе того же API.
- Обеспечить **достаточную открытость архитектуры**:
  - для дальнейшего перехода к:
    - мульти‑хабовой конфигурации (несколько сообществ);
    - частичной децентрализации (собственные ноды крупных участников, кластеры хабов).

### 1.2. Ограничения и допущения MVP

- Один **community‑hub** на сообщество (пока без кластера).
- Нет глобального блокчейна/ledger; есть:
  - локальная БД хаба;
  - подписи участников на ключевых записях (чтобы в будущем допустить миграцию).
- Упрощённый протокол:

  - транзакции проходят через хаб, который:
    - подбирает маршруты;
    - координирует подтверждения;
    - хранит лог операций;
  - при этом участники **подписывают** критические изменения (доверие, платежи), чтобы данные не зависели полностью от доверия к администратору хаба.

- Межсообществовый обмен — **вне MVP**, но архитектура предусматривает точки расширения.

---

## 2. Общий обзор архитектуры

### 2.1. Высокоуровневая схема

Логически система выглядит так:

```text
+---------------------------+
|     Пользователи (UX)    |
|  - Web-клиент (SPA/PWA)  |
|  - Mobile (опционально)  |
+-------------+-------------+
              |
              | HTTPS / WebSocket (JSON/REST)
              v
+---------------------------+
|     API Gateway / BFF     |
+-------------+-------------+
              |
              v
+---------------------------+
|     Community Hub Core    |
|  - Auth & Identity        |
|  - Trust Lines Service    |
|  - Payments Engine        |
|  - Routing (Pathfinding)  |
|  - Clearing Engine        |
|  - Reporting & Metrics    |
+-------------+-------------+
              |
              v
+---------------------------+
|       Data Layer          |
|  - PostgreSQL (основная)  |
|  - Redis (кэш, сессии)    |
+---------------------------+

+---------------------------+
| Crypto / Key Management   |
|  - Хранение ключей на    |
|    стороне клиента        |
|  - Подписание операций    |
+---------------------------+
```

Важный принцип:

- **Hub не должен быть «банком»**, принимающим решения за людей;
- он —:

  - вычислительный и коммуникационный узел;
  - индексатор данных;
  - координирующий сервис для выполнения протокола GEO.

---

## 3. Основные компоненты

### 3.1. Community‑hub Backend

Функции:

- Управление участниками:
  - регистрация/приглашения;
  - профили участников;
  - статус (активен/заморожен/ушёл).
- Аутентификация и сессии:
  - логин по email/телефону + пароль/OTP;
  - привязка к криптографическим ключам участника.
- Управление линиями доверия:
  - создание/изменение/закрытие;
  - хранение лимитов, текущих балансов, статуса.
- Платежный движок:
  - приём запросов на платёж;
  - подбор маршрутов;
  - выполнение протокола `prepare/commit`;
  - валидация подписей.
- Клиринговый движок:
  - поиск циклов (3–4 вершины в MVP);
  - формирование клиринговых транзакций;
  - координация подтверждений.
- Отчётность:
  - агрегированные данные по участникам;
  - балансы, обороты;
  - служебная аналитика.

### 3.2. API Gateway / BFF (Backend For Frontend)

- HTTP(S) REST + WebSocket (или SSE) для:

  - операций в реальном времени (платежи, уведомления);
  - обновления UI без постоянных опросов.

- Возможна реализация BFF в том же приложении, что и core (на этапе MVP).

### 3.3. Data Layer

**Основная БД: PostgreSQL**

- Таблицы:

  - `participants` — участники;
  - `equivalents` — эквиваленты (UAH, kWh, "час работы", …);
  - `trust_lines` — линии доверия;
  - `obligations` или `edges` — текущие обязательства/долги по парам участников;
  - `transactions` — факты операций;
  - `transaction_participants` — участники транзакции с их ролями;
  - `clearing_cycles` — зафиксированные циклы клиринга.

- Причины выбора:

  - транзакционная целостность (ACID);
  - хороший инструментарий для сложных запросов (поиск циклов можно частично делать SQL + приложение);
  - надёжность, зрелость, экосистема.

**Кэш / сессии: Redis**

- Короткоживущие данные:

  - сессии пользователей;
  - временные резервы по линиям доверия во время `prepare`;
  - очереди задач (можно вместо этого взять отдельный брокер сообщений, но Redis для MVP часто достаточно).

### 3.4. Клиентские приложения

**Web‑клиент (SPA/PWA)**

- Реализует:

  - UI для:

    - профиля участника;
    - управления линиями доверия;
    - создания платежей;
    - просмотра истории и балансов;
    - обзора сети доверия (упрощённые графы);

  - локальное хранение приватного ключа (в браузерном хранилище — WebCrypto + IndexedDB);
  - подписание важных операций (линию доверия, платёж).

- Рекомендуемые технологии:

  - React или Vue (на выбор команды);
  - TypeScript;
  - PWA‑поддержка (офлайн‑режим, установка на телефон).

⚠️ **УСТАРЕВШЕЕ для текущего репозитория (реализация GEOv0):** админка реализована как отдельный проект `admin-ui/` на **Vue 3 + TypeScript + Vite + Element Plus + Pinia**, а не как «React или Vue на выбор».

**Mobile‑клиент (опционально)**

- React Native / Flutter / Capacitor (обёртка над web‑клиентом).
- Повторяет функционал web‑клиента с мобильным UX.

### 3.5. Crypto / Key Management

Принципиально:

- **Приватные ключи пользователей хранятся на стороне клиента**, не на сервере.
- Сервер:

  - видит только публичные ключи;
  - получает подписи от клиентов;
  - проверяет их при приёме операций.

Реализация:

- Использование `libsodium` / `TweetNaCl` или аналогичных библиотек:
  - схемы подписи: `Ed25519` (удобная и широко поддерживаемая);
  - шифрование: `XChaCha20-Poly1305` (по мере необходимости).

Формат идентификаторов участника:

- `participant_id` может быть:

  - либо произвольным UUID (храним сопоставление с публичным ключом);
  - либо функцией от публичного ключа (например, `base58` от `SHA-256(pubkey)`).

### 3.6. Routing & Clearing Engine

**Routing (подбор платёжных путей)**

- Построение путей от A к B:

  - ограничение длины пути (например, до 4–5 узлов в MVP);
  - предпочтение более «надёжных» узлов (по репутации/ликвидности).

- Реализация:

  - в первый версии — алгоритм поиска в ширину (BFS) с фильтрацией по:

    - доступному лимиту (остатку доверия);
    - эквиваленту;
    - возможным политическим ограничениям (черные списки и т.п.).

  - более позднее — переход к:

    - k‑shortest paths;
    - max‑flow для составных платежей.

**Clearing (поиск циклов и клиринг)**

- Алгоритмы для поиска циклов длиной 3–4:

  - по заранее построенным подграфам;
  - либо через SQL‑запросы + обработку в приложении:
    - триплеты/квадруплеты `(A,B,C)`/`(A,B,C,D)` с ненулевыми взаимными долгами.

- Планировщик (cron/worker):

  - после каждой транзакции — искать короткие циклы в её окрестности;
  - периодически (раз в час/день) — фоновый поиск дополнительных циклов.

- Выполнение клиринга:

  - формирование специальной транзакции «нулевого платежа по циклу»;
  - запрос подтверждения от всех участников цикла (могут быть опции авто‑согласия);
  - изменение балансов.

---

## 4. Модель данных (логический уровень)

### 4.1. Participant (Участник)

Поля (основные):

- `id`: UUID / hash(pubkey).
- `public_key`: публичный ключ (Ed25519).
- `display_name`: отображаемое имя.
- `profile`: произвольные метаданные (описание, контакты, тип участника — физлицо, организация, хаб и т.п.).
- `status`: `active | suspended | left | deleted`.
- Агрегированные показатели (можно хранить в отдельных таблицах или как материализованные представления):

  - `total_incoming_trust` (сумма лимитов доверия _к нему_);
  - `total_outgoing_trust` (сумма лимитов доверия _от него_);
  - `total_debt` (его долг другим);
  - `total_credit` (долги других ему);
  - `net_balance` (чистая позиция).

### 4.2. Equivalent (Эквивалент)

- `id`: UUID.
- `code`: строка (например, `"UAH"`, `"HOUR_DEV"`, `"kWh"`).
- `description`: человекочитаемое описание.
- `precision`: количество знаков после запятой.

### 4.3. TrustLine (Линия доверия)

- `id`: UUID.
- `from_participant_id`: кто **даёт доверие**.
- `to_participant_id`: кому доверяют.
- `equivalent_id`.
- `limit`: максимальный объём доверия.
- `used`: текущий использованный объём (как _чистый_ долг `to` перед `from` в этом эквиваленте, ограниченный лимитом).
- `status`: `active | frozen | closed`.
- Метаданные:

  - `created_at`, `updated_at`;
  - `policies` (условия, например, авто‑подтверждение клиринга и т.п.).

Важно:

- `used` — не то же самое, что общий долг \(to \to from\); это конкретно **использование этой линии** в рамках всех операций.
- Чистый долг между двумя участниками по одному эквиваленту можно считать как функцию нескольких линий (если архитектура допускает более сложные схемы), но в MVP можно начать с **одной линии доверия на пару+эквивалент**.

### 4.4. Obligation / Debt (Обязательство)

Есть два варианта:

1. **Явная таблица долгов (рёбер)**

   - `from_participant_id` — должник;
   - `to_participant_id` — кредитор;
   - `equivalent_id`;
   - `amount`: текущий долг (может быть положительным/отрицательным при симметрии);
   - связь с транзакциями (через таблицу `transaction_effects`).

   При этом:

   - линию доверия `A→B` можно рассматривать как:
     - максимальный `amount` по `A→B` (или `B→A` в зависимости от модели);

2. **Хранить только `used` в `trust_lines` и вычислять чистые долги на лету**

   - проще по таблицам, но сложнее отслеживать длинные циклы, этим будет заниматься бизнес‑логика.

Для MVP практично **идти по пути 1**:

- отдельная таблица `debts` (или `obligations`), где явно хранить чистый долг по каждой паре и эквиваленту;
- `trust_lines` задают границы допустимых значений для этих долгов.

### 4.5. Transaction (Транзакция)

- `id`: UUID.
- `type`: `TRUST_LINE_CREATE | TRUST_LINE_UPDATE | PAYMENT | CLEARING | OTHER`.
- `status`: `PENDING | COMMITTED | ROLLED_BACK | FAILED`.
- `created_at`, `committed_at`.
- `initiator_id`: кто инициировал транзакцию.
- `payload`: JSON с бизнес‑данными (структурированный формат).
- `signatures`: массив цифровых подписей (участников, для которых транзакция критична).

Отдельная таблица:

- `transaction_participants`:

  - `transaction_id`;
  - `participant_id`;
  - `role`: `PAYER | PAYEE | INTERMEDIATE | TRUSTOR | TRUSTEE | CLEARING_MEMBER | ...`;
  - `signature` (если храним по ролям).

---

## 5. Жизненные циклы (flows)

### 5.1. Регистрация участника и ключи

1. Пользователь открывает web‑клиент.
2. Клиент генерирует пару ключей (Ed25519) локально и сохраняет приватный ключ:
   - в `IndexedDB`/secure storage + опциональный экспорт seed‑фразы.
3. Пользователь заполняет профиль (имя и т.п.) и отправляет на сервер:
   - `public_key`,
   - профиль,
   - опционально подпись заявления `REGISTER` этим ключом (для крипто‑связанности).
4. Сервер:
   - создаёт запись `participant`;
   - привязывает к `public_key`;
   - возвращает `participant_id` и данные профиля.
5. Клиент сохраняет `participant_id` и привязку к ключу.

Возможны варианты:

- регистрация через приглашение;
- базовая KYC‑процедура (зависит от сообщества).

### 5.2. Создание/изменение линии доверия

**Сценарий:** A даёт B доверие 100 в эквиваленте UAH.

1. В UI A выбирает B, вводит лимит.
2. Клиент A формирует запрос:

   - `from = A.id`,
   - `to = B.id`,
   - `equivalent = UAH`,
   - `limit = 100`,
   - `nonce` / `timestamp`.

   и **подписывает** его своим приватным ключом.

3. Запрос уходит на сервер.
4. Сервер:

   - проверяет подпись A;
   - проверяет внутренние политики (лимиты по умолчанию, пороги и т.п.);
   - создаёт или обновляет запись в `trust_lines`;
   - создаёт транзакцию типа `TRUST_LINE_CREATE/UPDATE` с подписью A;
   - опционально уведомляет B (через WebSocket/push).

5. Для изменений, требующих согласия B (например, сложные политики):

   - сервер отправляет B предложение;
   - B в своём клиенте подписывает согласие.

В MVP можно начать **с односторонней линии доверия**, не требующей подписи второй стороны (достаточно, что A несёт риск).

### 5.3. Платёж (покупка в кредит)

**Сценарий:** A платит C 60 в UAH.

Упрощённый вариант (один путь, короткая длина):

1. A в UI выбирает:

   - получателя C;
   - сумму и эквивалент.

2. Клиент A отправляет на сервер запрос `CreatePayment` (без подписи или с подписью, в MVP можно упростить).
3. Сервер:

   - находит один или несколько маршрутов \(A → N_1 → ... → C\);
   - проверяет доступные лимиты и остатки по линиям доверия и долгам;
   - формирует проект транзакции `PAYMENT`:

     - список изменений долгов по рёбрам;
     - участников и их роли.

4. Сервер рассылает участникам маршрутов `PREPARE`:

   - каждый узел (через свой клиент или в MVP — через серверное правило) проверяет:
     - укладывается ли в лимиты;
     - нет ли внутренних ограничений;
   - в продвинутом варианте: клиент каждого узла **подписывает** своё согласие.

5. При `OK` от всех:

   - сервер применяет изменения к `debts`/`trust_lines.used` в БД;
   - транзакция получает статус `COMMITTED`;
   - участникам шлются уведомления.

6. При `FAIL`任何:

   - транзакция помечается `ROLLED_BACK`;
   - временные резервы снимаются.

Для MVP допустимо:

- **не реализовывать полную 2‑фазную схему с подтверждениями клиентов**, а делать проверку на сервере, полагаясь на его роль координатора (особенно в доверенном сообществе).
- Но архитектурно всё равно закладывать:

  - поле `signatures`;
  - возможность перенести часть логики подтверждения на клиент позже.

### 5.4. Клиринг (замкнутый цикл 3–4 узла)

**Пример цикла:** A → B → C → A.

1. После каждой транзакции или по расписанию сервер:

   - строит подграф вокруг затронутых узлов;
   - ищет циклы 3–4 узла с ненулевыми взаимными долгами.

2. Нашёл цикл:

   - рассчитывает \(S = \min(\text{долг по каждому ребру})\);
   - формирует проект клиринга:
     - «уменьшить долг по каждому ребру цикла на S».

3. Создаёт транзакцию типа `CLEARING` со статусом `PENDING`.
4. Отправляет участникам цикла уведомление:

   - в MVP можно реализовать:
     - режим **авто‑согласия по умолчанию** с возможностью опт‑аут;
     - или явное согласие через UI.

5. После согласия всех:

   - применяет изменения к `debts`;
   - сохраняет транзакцию как `COMMITTED`.

6. Если хотя бы один против/не отвечает:

   - транзакция `FAILED`;
   - можно предлагать клиринг на меньшую сумму (по желанию).

---

## 6. Безопасность, приватность и устойчивость

### 6.1. Безопасность

- Пароли храним только в виде `bcrypt/argon2`‑хэшей.
- Авторизация:

  - JWT‑токены с коротким сроком жизни;
  - refresh‑токены с более длинным сроком;
  - TLS везде.

- Подписи:

  - все операции настройки доверия и клиринга могут (поэтапно) переводиться на **обязательное крипто‑подписание**;
  - для MVP можно начать с подписи хотя бы установления доверия.

- Защита от инъекций, CSRF, XSS:

  - стандартные практики web‑разработки;
  - CSP, CSRF‑tokens и т.д.

### 6.2. Приватность

- Хаб видит все транзакции: это **компромисс на уровне MVP**.
- Для уменьшения вреда:

  - минимизация логирования чувствительных данных;
  - чёткая политика доступа администраторов;
  - опция шифрования части полей (описания сделок, комментарии).

- В дальнейшем можно:

  - переносить часть логики и данных в p2p между клиентами;
  - использовать клиент‑клиент шифрование для контента сделки.

### 6.3. Устойчивость

- Резервные копии:

  - регулярный бэкап PostgreSQL (полный + инкрементальный);
  - резервирование конфигурации и метаданных.

- Масштабирование по вертикали на MVP:

  - один хаб в пределах 50–500 участников выдержит нагрузку легко.

- Подготовка к кластеризации (переход к Архитектуре C):

  - чёткое разделение:

    - уровня «журнала операций»;
    - уровня «проекции/индексов»;

  - чтобы при необходимости можно было поставить реплики, а затем ввести консенсус между ними.

---

## 7. Рекомендуемый технологический стек

⚠️ **УСТАРЕВШЕЕ для текущего репозитория (реализация GEOv0):** ниже в разделе 7 описаны варианты стека, которые рассматривались на этапе концепции (TypeScript/NestJS/React и др.).

Актуальный стек реализации (см. канон: [`docs/ru/03-architecture.md`](docs/ru/03-architecture.md:1)):

- Backend: Python + FastAPI + SQLAlchemy + Alembic + PostgreSQL + Redis
- Admin UI: Vue 3 + TypeScript + Vite + Element Plus + Pinia

### 7.1. Backend

Вариант 1 (очень распространённый):

- **Язык:** TypeScript
- **Фреймворк:** NestJS или Fastify (с модульной архитектурой).
- **БД:** PostgreSQL (через TypeORM/Prisma/knex).
- **Кэш/очереди:** Redis.
- **Testing:** Jest.
- **Инфраструктура:** Docker, docker‑compose для dev; Kubernetes или bare‑metal для прод.

Плюсы:

- огромная экосистема;
- много разработчиков;
- легко интегрировать с JS‑фронтендом.

Вариант 2 (для любителей функциональности и высокой нагрузки):

- **Язык:** Go или Elixir (Phoenix).
- Аналогичный стек БД + Redis.

Для MVP разумно взять **TypeScript + NestJS**, если у команды нет сильных предпочтений.

### 7.2. Frontend

- **React + TypeScript**:

  - UI‑кит: MUI / Chakra UI / TailwindCSS;
  - библиотека запросов: React Query / TanStack Query;
  - Graph rendering (для визуализации сети доверия): `vis-network`, `d3`, `react-force-graph` (по вкусу).

- PWA‑конфигурация для «квазимобильного» опыта.

### 7.3. Криптография

- Библиотеки:

  - `libsodium` или обёртки (`tweetnacl`, `libsodium-wrappers`);
  - Стандарты:

    - подписание: Ed25519;
    - хэширование: SHA‑256/512.

- Хранение приватных ключей:

  - browser: WebCrypto + IndexedDB;
  - мобильные клиенты: secure storage платформы (Keychain / Keystore).

---

## 8. Эволюция архитектуры (заготовки на будущее)

### 8.1. Кластеризация хаба

Переход от одного хаба к нескольким:

- Вводим:

  - 2–3 backend‑инстанса;
  - общую БД PostgreSQL (первый шаг);
  - балансировщик нагрузки (Nginx/Traefik).

- Далее опционально:

  - реплики PostgreSQL (hot standby);
  - разделение чтения/записи;
  - в перспективе — введение консенсусного журнала (Raft и т.п.).

### 8.2. Межсообществовое взаимодействие

Для объединения нескольких хабов в кластер:

- Добавляем сущность **Community / Hub**:

  - каждый хаб — участник‑узел на уровне meta‑сети GEO;
  - между хабами открываются линии доверия (на уровне юрлиц/организаций).

- Вводим протокол:

  - `Hub-to-Hub`:

    - запросы платежей между участниками разных хабов;
    - агрегированный клиринг между хабами.

- На уровне MVP достаточно спроектировать API‑контракты:

  - `POST /interhub/payment-request`
  - `POST /interhub/clearing-proposal`
  - и т.п., но не реализовывать их полностью.

### 8.3. Частичный переход к P2P

Для крупных/технически подготовленных участников:

- возможность запускать **собственный узел**, который:

  - хранит локально все свои данные;
  - синхронизируется с хабом через расширенный API;
  - по некоторым операциям может общаться напрямую с другими узлами (в будущем).

Это потребует:

- дальнейшего развития ключевого протокола (ID, подписи, маршрутизация);
- но уже сейчас:

  - важно **не «приваривать» логику к одному серверу**;
  - всегда хранить криптографические подтверждения действий участников.

---

## 9. Объём MVP (что включено / не включено)

### 9.1. Включено в MVP

- Регистрация участников и базовый профиль.
- Управление линиями доверия (минимум — односторонние лимиты).
- Создание платежей:

  - прямые (A → B);
  - через один посредник (A → X → B) — как минимум.
- Простой движок поиска путей (BFS) с ограничением по длине пути.
- Поиск и выполнение клиринга для циклов из 3–4 участников.
- Web‑клиент с основными экранами:

  - дашборд баланса;
  - список и настройка линий доверия;
  - форма платежа;
  - история операций;
  - (опционально) простая визуализация сети доверия.

### 9.2. Не включено (но учитывается архитектурой)

- Полноценный P2P‑режим между клиентами.
- Сложный межхабовый протокол и межсообществовый клиринг.
- Формальный консенсус между несколькими хабами (мини‑ledger).
- Сложные экономические политики (динамические лимиты, риск‑скоринг и т.п.).
- Глубокая интеграция с внешними платёжными системами/фиатом.

---

## 10. Заключение

Предложенная архитектура **community‑hub + лёгкие клиенты**:

- даёт реалистичный путь к **рабочему MVP** для одного локального сообщества;
- сохраняет ключевые идеи GEO:

  - линии доверия и взаимный кредит;
  - поиск платёжных путей;
  - автоматический клиринг циклов;

- при этом:

  - не вводит преждевременно сложные распределённые консенсусы;
  - чётко отделяет протокол (подписи, сущности) от конкретной реализации (один сервер);
  - оставляет пространство для эволюции к:

    - кластеру хабов в сообществе;
    - межсообществовой сети;
    - частично p2p‑архитектуре.

На следующем шаге можно:

1. Сузить технологический стек до конкретных библиотек и версий.
2. Составить **список user‑stories** и функциональных требований для MVP (backlog).
3. Описать **конкретные API‑эндпоинты** (REST/WS) и форматы сообщений для:

   - линий доверия;
   - платежей;
   - клиринга.

После этого можно переходить к проектированию схемы БД и началу реализации прототипа.
