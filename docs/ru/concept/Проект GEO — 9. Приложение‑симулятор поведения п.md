# GEO — Приложение‑симулятор поведения пользователей

> Спецификация приложения для симуляции, тестирования и визуализации сети GEO

---

## Оглавление

1. [Введение](#1-введение)
2. [Основной функционал симулятора](#2-основной-функционал-симулятора)
   - 2.1. [Конфигурация «мира»](#21-конфигурация-мира-генерация-сети)
   - 2.2. [Поведенческие сценарии](#22-поведенческие-сценарии-модели-взаимодействия)
   - 2.3. [Управление нагрузкой](#23-управление-нагрузкой)
   - 2.4. [Взаимодействие с API ядра](#24-взаимодействие-с-реальным-api-ядра)
3. [Визуализация и аналитика](#3-визуализация-и-аналитика)
   - 3.1. [Граф сети доверия и долгов](#31-граф-сети-доверия-и-долгов)
   - 3.2. [Агрегированные метрики](#32-агрегированные-метрики-во-времени)
   - 3.3. [Показатели эффективности протокола](#33-показатели-эффективности-протокола)
   - 3.4. [Режим «реплея»](#34-режим-реплея)
4. [Настройки и сценарии для ТЗ](#4-настройки-и-сценарии-для-тз)
5. [Концепция визуализации](#5-концепция-визуализации)
6. [Экран «Карта сообщества»](#6-экран-карта-сообщества)
   - 6.1. [Компоновка экрана](#61-компоновка-экрана)
   - 6.2. [Отображение участников](#62-отображение-участников-узлов)
   - 6.3. [Отображение связей](#63-отображение-связей-trustlines-и-долги)
7. [Группировка участников](#7-группировка-участников)
   - 7.1. [По типам и ролям](#71-по-типам-и-ролям)
   - 7.2. [По кластерам доверия](#72-по-кластерам-доверия)
   - 7.3. [По финансовым показателям](#73-по-финансовым-показателям)
8. [Действия пользователя](#8-действия-пользователя)
   - 8.1. [Действия с участником](#81-действия-с-участником-узлом)
   - 8.2. [Действия с линиями доверия](#82-действия-с-линиями-доверия-и-долгами)
9. [Режим «Маршруты платежей и клиринг»](#9-режим-маршруты-платежей-и-клиринг)
10. [Режим списка участников](#10-режим-агрегированного-списка-участников)
11. [Рекомендуемый технический стек](#11-рекомендуемый-технический-стек)
    - 11.1. [Основной стек (React)](#111-основной-стек-react)
    - 11.2. [Альтернатива (Python)](#112-альтернативный-стек-python)
12. [UI‑спецификация экрана «Карта сообщества»](#12-ui‑спецификация-экрана-карта-сообщества)
    - 12.1. [Общая структура](#121-общая-структура-экрана)
    - 12.2. [Top Bar](#122-top-bar)
    - 12.3. [Left Sidebar](#123-left-sidebar)
    - 12.4. [Main Canvas](#124-main-canvas)
    - 12.5. [Right Sidebar](#125-right-sidebar)
    - 12.6. [Состояния экрана](#126-состояния-экрана-в-целом)
13. [Интеграция ИИ в симулятор сценариев и поведения](#13-интеграция-ии-в-симулятор-сценариев-и-поведения)

---

## 1. Введение

**Отдельное приложение, которое имитирует живое сообщество** и нагружает ядро GEO, а также визуализирует результаты. Это одновременно:

- генератор трафика и сценариев поведения;
- инструмент нагрузочного тестирования;
- лаборатория для экспериментов с протоколом (routing, clearing, политики доверия).

### Общая идея

Приложение подключается к API hub'а как множество «виртуальных пользователей» (участников), создаёт и управляет ими, открывает между ними trustlines, генерирует платежи, инициирует/реагирует на клиринг. По сути, это **симуляция экономики сообщества** поверх реального ядра GEO.

**Цели:**

- проверить производительность и устойчивость реализации;
- проверить корректность логики (особенно клиринга, ограничений лимитов, идемпотентности);
- исследовать, как разные топологии доверия и модели поведения влияют на:
  - эффективность взаимозачетов;
  - распределение долгов/кредитов;
  - среднюю длину маршрутов и частоту отказов;
- находить баги и узкие места ещё до того, как система попадёт к реальным пользователям.

---

## 2. Основной функционал симулятора

### 2.1. Конфигурация «мира» (генерация сети)

> **MVP-подход:** Начать с JSON-конфигурации (список участников + список trustlines). Динамическую генерацию добавить позже.

Возможность задать параметры сети через JSON-файл:

```json
{
  "participants": [
    { "id": "p1", "name": "Иван", "type": "person" },
    { "id": "p2", "name": "Кофейня", "type": "organization" }
  ],
  "trustlines": [
    { "from": "p1", "to": "p2", "limit": 1000 }
  ]
}
```

Параметры конфигурации:

- количество участников;
- типы участников (обычные, «центральные» узлы, hubs и т.п.);
- список trustlines с указанием лимитов;
- **один эквивалент** (например, `UAH`) — для MVP этого достаточно.

Симулятор может:

- **загружать готовые JSON-сценарии** (основной режим для MVP);
- автоматически генерировать сеть (расширенный режим, добавить позже).

### 2.2. Поведенческие сценарии (модели взаимодействия)

Модели, которые описывают, как участники ведут себя во времени:

- **«случайный рынок»** — участники случайно выбирают друг друга и совершают платежи;
- **«кластерный обмен»** — более интенсивный обмен внутри подгрупп, редкий между ними;
- **«клиент‑поставщик»** — одни участники в основном продают, другие в основном покупают;
- **стресс‑сценарии**:
  - всплеск активности;
  - отключение части участников (suspended);
  - резкая смена лимитов trustlines.

Модели должны настраиваться:

- интенсивность транзакций (сколько платежей в секунду/минуту/час);
- распределение сумм платежей;
- вероятность изменения trustlines (увеличение/уменьшение лимитов, закрытие).

### 2.3. Управление нагрузкой

> **MVP-подход:** Один слайдер «интенсивность» (0–100%) вместо нескольких профилей.

Возможность динамически изменять:

- общее число активных «виртуальных пользователей»;
- **интенсивность симуляции** — один слайдер 0–100%:
  - 0% — симуляция на паузе;
  - 25% — спокойный день;
  - 50% — обычная нагрузка;
  - 75% — пиковый час;
  - 100% — стресс-тест.

Соотношение типов операций (для расширенного режима):

- сколько процентов — платежи;
- сколько — изменения trustlines;
- сколько — искусственно инициированные клиринги.

### 2.4. Взаимодействие с реальным API ядра

Симулятор не должен «лезть в БД напрямую», а использовать те же интерфейсы, что и реальные клиенты:

- регистрация участников через API;
- создание trustlines через API;
- отправка `PAYMENT_REQUEST` и ожидание результата;
- мониторинг состояний транзакций.

Это гарантирует, что мы тестируем именно протокольный слой и логику, а не только внутренние функции.

---

## 3. Визуализация и аналитика

Очень важная часть — **наглядное отображение того, что происходит в сети**.

### 3.1. Граф сети доверия и долгов

- **Узлы** — участники;
- **Рёбра**:
  - trustlines (лимиты);
  - поверх них — текущие долги;
- **Цвет/толщина рёбер**:
  - величина лимита;
  - степень использования (долг/лимит);
- **Возможность**:
  - включать/выключать отображение доверия/долгов;
  - подсвечивать маршруты конкретных платежей;
  - видеть, какие рёбра чаще всего участвуют в клиринге.

### 3.2. Агрегированные метрики во времени

> **MVP-подход:** Вместо 10+ метрик достаточно 4–5 ключевых.

**Ключевые метрики для MVP:**

| Метрика | Зачем |
|---------|-------|
| Общий объём долгов | Понять масштаб системы |
| % успешных платежей | Оценить работоспособность |
| Средняя длина маршрута | Оценить эффективность сети |
| Объём клиринга | Оценить работу взаимозачётов |
| Топ-5 «узких мест» | Найти перегруженных участников |

**Расширенные метрики (после MVP):**

- Распределение длины маршрутов (максимум);
- Частота отказов по причинам:
  - нет маршрута;
  - недостаток лимита;
  - таймаут 2PC.
- Графики по времени (time series), возможность перемотки/просмотра истории.

### 3.3. Показатели эффективности протокола

- **Эффективность взаимозачётов** — отношение суммы клиринга к сумме всех проведённых платежей;
- **Концентрация долгов** — какие участники становятся «узкими местами» (на них замыкается много долгов);
- **Стабильность сети** — как часто система приходит в состояния, когда новые платежи «не проходят» из‑за перегруженности определённых рёбер.

### 3.4. Режим «реплея»

> ⚠️ **Не для MVP** — требует сложной сериализации состояния. Реализовать после базового функционала.

- Возможность записать сценарий (или фрагмент симуляции);
- Затем проигрывать его с разной скоростью;
- Сравнивать, как повели бы себя разные версии протокола/алгоритмов.

---

## 4. Настройки и сценарии для ТЗ

В перспективе ТЗ для такого приложения может включать:

- **Ядро симуляции:**
  - движок сценариев (скриптовый язык или конфигурационные файлы);
  - генератор событий (tick‑based или event‑based).

- **Сценарные настройки:**
  - параметры генерации сети;
  - профили поведения участников;
  - планировщик событий (в какое время что меняется).

- **Поддержка реплики и воспроизводимости:**
  - фиксированные seed'ы для генераторов случайных чисел;
  - сохранение конфигураций и результатов прогонов.

- **Поддержка разных версий backend'а GEO:**
  - возможность запускать симуляцию против разных инстансов ядра (например, v0.1, v0.2).

Такое приложение станет не только инструментом тестирования, но и **исследовательской лабораторией** для развития протокола GEO.

---

## 5. Концепция визуализации

Визуальная часть приложения может иметь **два основных режима**:

1. **«Социально‑экономический радар»** — обзорное представление сообщества:
   - кто есть кто,
   - кто с кем связан,
   - как течёт ценность.

2. **«Рабочий стол участника»** — фокус на самом пользователе:
   - мои связи (trustlines),
   - мои долги и кредиты,
   - мои действия (заплатить, изменить лимит, согласиться на клиринг и т.п.).

Оба режима могут быть доступны и в браузере (web‑интерфейс), и в нативном/кроссплатформенном клиенте.

---

## 6. Экран «Карта сообщества»

### 6.1. Компоновка экрана

**По центру** — интерактивный граф:

- **узлы** — участники;
- **рёбра** — связи доверия и/или долга между ними.

**Слева** — фильтры и слои:

- включить/выключить:
  - линии доверия (лимиты);
  - долги (реальные обязательства);
- выбрать эквивалент (UAH, HOUR, LOCAL_UNIT и т.д.);
- фильтровать по типу участников.

**Справа** — панель информации о выбранном элементе:

- если выбран участник: краткая карточка профиля, агрегированные показатели, доступные действия;
- если выбрано ребро: детали trustline и долга между участниками.

**Сверху** — панель режимов визуализации:

- «Сеть доверия» (TrustLines);
- «Сеть долгов» (Debts);
- «Маршруты платежей»;
- «Кластеры».

### 6.2. Отображение участников (узлов)

Каждый участник на графе — это **иконка + метка**:

- **Форма/значок** кодирует тип:
  - кружок — физлицо;
  - квадрат — организация;
  - шестиугольник — hub.

- **Цвет узла** означает состояние:
  - зелёный — активен (`active`);
  - жёлтый — ограничен/под наблюдением (`suspended`);
  - серый — покинул (`left`) или выключен;
  - красная обводка — участник часто фигурирует в спорах или имеет аномальные показатели.

При наведении курсора всплывает **мини‑подсказка**: имя, короткий статус, количество связей доверия.

При клике на узел открывается правая панель с подробной информацией.

### 6.3. Отображение связей (trustlines и долги)

Между участниками рисуются рёбра:

- **TrustLines**:
  - тонкие линии, цветом показывающие направление доверия;
  - стрелка от `from` к `to`;
  - насыщенность/толщина — величина лимита.

- **Debts**:
  - более толстые или выделенные линии;
  - направление — от должника к кредитору;
  - интенсивность цвета — размер долга.

Пользователь может:

- включать режим «только trustlines» или «только долги»;
- интерактивно «подсветить» связи конкретного участника.

---

## 7. Группировка участников

### 7.1. По типам и ролям

Группировка по:

- типу (`person`, `organization`, `hub`);
- роли в сообществе (например, «координатор», «поставщик услуг», «крупный покупатель»).

Реализация: цветовые коды или разные иконки; возможность выделить одну группу.

### 7.2. По кластерам доверия

> ⚠️ **MVP-подход:** На MVP отключить автоматическую кластеризацию. Показывать только ручную группировку по типу участника (см. 7.1).

В расширенном режиме на основе анализа графа можно автоматически выделять **кластеры**:

- группы участников, у которых много взаимных линий доверия;
- локальные «сообщества внутри сообщества» (районы, профессиональные группы).

Визуально:

- узлы одного кластера подсвечиваются одинаковым фоном/рамкой;
- режим «свернуть кластеры»: каждый кластер показывается как один крупный узел.

### 7.3. По финансовым показателям

Фильтры и цветовые градиенты:

- **по net‑балансу**: положительный (кредитор) — один цвет; отрицательный (должник) — другой;
- **по активности**: частота операций за последние N дней.

Это позволяет:

- увидеть «узкие места» (участники, через которых проходит слишком много операций);
- выявить потенциальные риски (сильно закредитованные).

---

## 8. Действия пользователя

### 8.1. Действия с участником (узлом)

**Обычный участник**, выбирая другого участника на графе, может:

- **Открыть панель профиля** — посмотреть публичную информацию, увидеть свои отношения с ним;
- **Создать/изменить линию доверия** — задать лимит, выбрать эквивалент, изменить политику;
- **Инициировать платёж** — указать сумму и эквивалент, увидеть предварительную оценку маршрута;
- **Посмотреть историю взаимодействий** — список платежей, изменения trustlines.

**Администратор/координатор** при выборе участника может дополнительно:

- **Изменить статус** участника (`suspended`, `left`);
- **Посмотреть риски и аномалии**;
- **Перейти к инструментам урегулирования споров**.

### 8.2. Действия с линиями доверия и долгами

При клике на ребро показывается:

- **детали trustline** `A→B`: текущий лимит, политика, дата создания/изменения;
- **детали долга** `B→A`: текущая сумма, история изменений.

**Обычный участник** (если это его trustline) может: изменить лимит, изменить политику, закрыть линию доверия.

**Администратор** может: видеть дополнительные технические данные, запускать аналитические инструменты.

---

## 9. Режим «Маршруты платежей и клиринг»

Для прозрачности работы протокола и отладки:

- пользователь выбирает конкретный платёж (по `tx_id`);
- система **подсвечивает маршрут**: узлы и рёбра, которые задействованы; стрелками показывает, как перераспределились долги.

**Режим показа циклов клиринга**:

- при выборе транзакции `CLEARING`: подсвечивается цикл `A → B → C → A`;
- на каждом ребре показывается: сколько было долга до клиринга, сколько стало после, какая часть «схлопнулась».

---

## 10. Режим агрегированного списка участников

Помимо графического вида нужна **таблично‑карточная** форма списка участников.

Таблица/список может содержать для каждого участника:

- имя/название;
- тип;
- net‑баланс;
- количество входящих/исходящих trustlines;
- индикаторы активности и надёжности.

**Возможные действия:**

- поиск и фильтрация;
- клик по строке — переход к карточке участника и/или подсветке его на графе;
- массовые операции (для админов): экспорт данных, отправка уведомлений.

---

## 11. Рекомендуемый технический стек

### 11.1. Основной стек (React)

Для отдельного аналитического/симуляционного веб‑инструмента React даёт почти идеальный баланс:

- огромное сообщество;
- море готовых решений;
- ИИ‑агенты лучше всего умеют генерировать именно React+TS‑код.

**Рекомендуемый стек:**

| Компонент | Технология | Примечание |
|-----------|------------|------------|
| Язык | TypeScript | — |
| UI‑фреймворк | React | — |
| UI‑кит | MUI (Material UI) | — |
| Граф (network) | `react-force-graph-2d` | ⚠️ Использовать 2D, не 3D — проще и достаточно для MVP |
| Чарты | `Recharts` | Декларативный, простой |
| Работа с API | React Query (TanStack Query) | — |
| Сборка | Vite | — |

**Технические ограничения:**

- **Ограничить размер графа** — при >100 узлах переключаться на агрегированный вид. Force-directed layout плохо работает с >500 узлами.
- **Throttle обновлений** — при активной симуляции не перерисовывать граф чаще 2–3 раз в секунду.
- **Оффлайн-режим** — возможность загрузить snapshot состояния и анализировать без подключения к backend.

**Почему это «минимальный кодинг»:**

- Практически все визуальные компоненты будут **композицией готовых библиотек**;
- Реальный «ручной» код — это в основном **склейка**: запросы к API, преобразование данных, логика фильтрации.

### 11.2. Альтернативный стек (Python)

Если хочется полностью избежать JS‑мира:

**Dash (Plotly Dash):**

- Python‑код описывает layout и callbacks;
- есть `dash-cytoscape` для граф‑визуализации;
- Plotly графики для метрик;
- легко деплоится.

**Streamlit:**

- ещё более простой синтаксис;
- много примеров;
- для сложной граф‑визуализации может понадобиться больше костылей.

Это особенно хорошо, если основная аудитория — разработчики/исследователи.

---

## 12. UI‑спецификация экрана «Карта сообщества»

Компактная, но подробная спецификация для генерации кода (React/Flutter).

### 12.1. Общая структура экрана

Экран делится на 4 основных области (ИИ‑функции интегрированы так, чтобы не перегружать центральное полотно):

1. **Top Bar** — верхняя панель навигации, режимов, статуса симуляции и быстрых действий ИИ (объяснить, предложить стресс‑тест, открыть панель ввода).
2. **Left Sidebar** — фильтры, слои, выбор сценария/симуляции и **панель ИИ‑сценариста**: ввод текстовых описаний, предпросмотр сгенерированных сценариев и патчей, история запросов.
3. **Main Canvas** — центральное полотно с графом участников, поверх которого отображаются подсветки/оверлеи от ИИ (узкие места, зоны риска, превью стресс‑сценариев).
4. **Right Sidebar** — детальная панель выбранного элемента, включая вкладку **«AI Insight»** с локальными объяснениями и рекомендациями по выбранному узлу/связи/кластеру.

```
CommunityMapPage
├── TopBar
└── Layout
    ├── LeftSidebar
    │   └── AiScenarioPanel
    ├── MainCanvas
    │   └── GraphView
    └── RightSidebar
        └── DetailsPanels (включая AI Insight)
```

### 12.2. Top Bar

**Компонент: `TopBar`**

| Элемент | Компонент | Состояния |
|---------|-----------|-----------|
| Логотип | `AppLogo` | нормальное, компактное |
| Режимы | `ViewModeTabs` | `activeTab: 'Network' \| 'Metrics'` (⚠️ Replay — не для MVP) |
| Статус | `SimulationStatusIndicator` | `connectionStatus`, `simulationStatus` |
| Управление симуляцией | `SimulationControls` | Start/Stop/Pause/Resume/Speed |
| Быстрые ИИ‑действия | `AiQuickActions` | `canExplain`, `canSuggestStress`, `isBusy` |

**`AiQuickActions` — пример набора кнопок:**

- `ExplainCurrentView` — запросить у ИИ объяснение текущего состояния для видимой области графа (использует `/ai/explain-current-state`).
- `SuggestStressScenarios` — попросить ИИ предложить 1–3 релевантных стресс‑сценария для текущего мира (`/ai/generate-stress-scenarios`).
- `OpenAiPanel` — разворачивает панель ИИ‑сценариста в левом сайдбаре и устанавливает фокус в текстовое поле.

**Горячие клавиши (UX‑улучшение):**

| Клавиша | Действие |
|---------|----------|
| `Space` | Пауза/продолжение симуляции |
| `R` | Reset (сброс симуляции) |
| `+` / `-` | Увеличить/уменьшить скорость |
| `Esc` | Снять выделение с узла/ребра / закрыть модальные панели |
| `E` | Запросить объяснение текущего состояния от ИИ (`ExplainCurrentView`) |
| `T` | Попросить ИИ предложить стресс‑сценарии (`SuggestStressScenarios`) |

### 12.3. Left Sidebar

**Компонент: `LeftSidebar`**

Внутренняя структура:

- `QuickStartBanner` — ⭐ UX‑улучшение: при первом запуске предлагает загрузить demo‑сценарий с 10–20 участниками.
- `ScenarioSelector` — выбор сценария симуляции (в том числе сценариев, сгенерированных ИИ).
- `AiScenarioPanel` — панель взаимодействия с ИИ‑сценаристом.
- `LayerToggles` — переключатели слоёв.
- `FiltersPanel` — фильтры участников.
- `ExportButton` — экспорт графа в PNG/SVG.

**`AiScenarioPanel` — состав:**

- `AiPromptInput` — многострочное текстовое поле:
  - placeholder: «Опишите мир, поведение или изменения, которые хотите внести…»
  - кнопки:
    - `GenerateScenario` — создать новый сценарий;
    - `ApplyPatch` — применить изменения к текущему сценарию.
- `AiSummaryBox` — краткое резюме последнего ответа ИИ:
  - количество участников/групп;
  - ключевые профили поведения и их доли;
  - краткое описание предложенных изменений/событий.
- `AiRequestsHistory` — компактный список последних 3–5 запросов/ответов:
  - клик по элементу — разворачивает подробности (JSON‑дифф, предпросмотр на графе).
- `AiStatusBar` — индикатор:
  - `idle` / `thinking` / `error`;
  - при ошибке показывает текстовое сообщение от ИИ/валидации.

**Состояния `AiScenarioPanel`:**

```ts
ai.state: 'idle' | 'thinking' | 'error';

ai.lastRequest?: {
  text: string;
  type: 'scenario' | 'patch';
  createdAt: string;
};

ai.lastResultSummary?: {
  participantsCount: number;
  groupsCount: number;
  mainProfiles: Array<{ id: string; share: number }>;
  mainNotes: string[];
};
```

**`LayerToggles` — состояния:**

```ts
showTrustLines: boolean;
showDebts: boolean;
showPaymentRoutes: boolean;
showClusters: boolean;
showAiOverlays: boolean; // подсветки и оверлеи ИИ
```

**`FiltersPanel` — состояния:**

```ts
filter.types: { person: boolean; organization: boolean; hub: boolean };
filter.statuses: { active: boolean; suspended: boolean; left: boolean };
filter.equivalentCode: string | 'ANY';
filter.netBalanceRange: [number, number];
filter.activityRange: [number, number];
filter.aiFlags?: {
  bottleneckOnly?: boolean;       // показывать только «узкие места» по версии ИИ
  overTrustedOnly?: boolean;      // участники с избыточным доверием
  stressAffectedOnly?: boolean;   // участники, затронутые выбранным стресс‑сценарием
};
```

### 12.4. Main Canvas

**Компонент: `GraphView`**

Обёртка над библиотекой (например, `react-force-graph`), с поддержкой ИИ‑оверлеев:

```ts
type PID = string;

interface AiFlags {
  bottleneck?: boolean;      // узкое место по версии ИИ
  overTrusted?: boolean;     // «слишком доверчивый» узел
  stressAffected?: boolean;  // затронут стресс‑сценарием
}

interface ParticipantNode {
  id: PID;
  name: string;
  type: 'person' | 'organization' | 'hub';
  status: 'active' | 'suspended' | 'left';
  netBalance: number;
  activityScore: number;
  clusterId?: string;
  aiFlags?: AiFlags;
}

interface LinkEdge {
  id: string;
  from: PID;
  to: PID;
  kind: 'trustline' | 'debt';
  equivalent: string;
  limit?: number;      // для trustline
  amount?: number;     // для debt
  utilization?: number;
  aiFlags?: {
    bottleneck?: boolean;
    stressAffected?: boolean;
  };
}

interface AiHighlight {
  nodeIds?: PID[];
  linkIds?: string[];
  reason?: string; // краткое текстовое объяснение для тултипа/легенды
}
```

**Props:**

- `nodes: ParticipantNode[]`
- `links: LinkEdge[]`
- `viewMode: 'trustlines' | 'debts' | 'combined'`
- `highlightedNodeId?: PID`
- `highlightedLinkId?: string`
- `aiHighlight?: AiHighlight` — текущая подсветка от ИИ (узкие места, область фокуса объяснения, превью стресс‑сценария)
- `onNodeClick(nodeId: PID)`
- `onLinkClick(linkId: string)`
- `onBackgroundClick()`
- `onAreaSelect?(bounds: { x1: number; y1: number; x2: number; y2: number })` — выделение области для локального объяснения ИИ

**Визуальные состояния узлов:**

| Тип | Форма |
|-----|-------|
| `person` | круг |
| `organization` | квадрат |
| `hub` | шестиугольник |

| Статус | Цвет |
|--------|------|
| `active` | зелёный |
| `suspended` | жёлтый |
| `left` | серый |

Дополнительно, при наличии `aiFlags`:

- `bottleneck` — обводка узла более толстой линией, иконка «⚠» в тултипе;
- `overTrusted` — дополнительный маркер (например, кольцо другого цвета);
- `stressAffected` — полупрозрачная заливка или «пульсация» при превью стресс‑сценария.

### 12.5. Right Sidebar

**Компонент: `RightSidebar`**

Подкомпоненты:

- `NodeDetailsPanel` — если выбран участник.
- `LinkDetailsPanel` — если выбрана связь.
- `AiInsightPanel` — вкладка с объяснением от ИИ для выбранного элемента/области и предложениями по действиям.
- `EmptySelectionPanel` — если ничего не выбрано.

**`NodeDetailsPanel` — структура:**

1. Карточка профиля (имя, тип, статус).
2. Краткие метрики (net‑баланс, количество trustlines).
3. Список связей (вкладки: TrustLines / Debts).
4. Действия (Create TrustLine, Initiate Payment, View History).
5. Краткий индикатор ИИ‑оценки риска (если есть `aiFlags`):
   - бейджи: «Узкое место», «Over‑trust», «Затронут стресс‑сценарием».

**`LinkDetailsPanel` — структура:**

1. Заголовок (`A → B`, тип).
2. Основные поля (limit/amount, policy).
3. График изменения (sparkline).
4. Действия (Edit Limit, Edit Policy, Close TrustLine).
5. Метка ИИ‑аналитики (если связь помечена как узкое место или критический маршрут).

**`AiInsightPanel` — структура:**

1. Заголовок (`AI Insight for [узел/связь/область]`).
2. Текстовое объяснение от ИИ (краткий отчёт из `/ai/explain-current-state` для выбранного контекста).
3. Список ключевых факторов:
   - вклад в общую нагрузку;
   - роль в отказах/успехах платежей;
   - участие в стресс‑сценариях.
4. **Предлагаемые ИИ планы действий** (если есть рекомендации по кризису, см. 13.7):
   - список карточек планов с краткими описаниями и прогнозным эффектом;
   - кнопки: «Запустить симуляцию плана» и «Применить к текущему сценарию».
5. Рекомендованные ручные действия (если планы не применяются автоматически):
   - «уменьшить лимиты на этих trustlines»;
   - «добавить альтернативные маршруты в обход узла»;
   - «переопределить поведение части участников» (с ссылкой на `AiScenarioPanel`).

### 12.6. Состояния экрана в целом

| Состояние | Поведение |
|-----------|-----------|
| Empty/No‑Data | GraphView показывает пустое состояние с подсказкой, `AiScenarioPanel` предлагает загрузить demo‑сценарий или сгенерировать его через ИИ |
| Loading | Skeleton‑элементы или лоадер в центре, TopBar показывает `simulationStatus = 'loading'` |
| Error | Баннер в верхней части экрана, `SimulationStatusIndicator` в состоянии `error`; `AiScenarioPanel` может отображать детали ошибки при генерации сценария |
| AI‑запрос выполняется | `AiScenarioPanel` и `AiQuickActions` показывают статус `thinking`, часть кнопок блокируется до завершения запроса |
| AI‑оверлей активен | На графе подсвечиваются узлы/связи по данным `aiHighlight`, в легенде/правой панели отображается пояснение, какой именно оверлей включён (узкие места, стресс‑превью и т.п.) |
| План действий выбран | `AiInsightPanel` показывает детали выбранного плана, `MainCanvas` может визуализировать предполагаемые изменения (превью патча) до применения |

---

## Рекомендации по улучшению приложения

> Ниже — дополнительные улучшения, которые можно реализовать после MVP. Базовые упрощения (один эквивалент, JSON-конфигурация, упрощённый UI и т.д.) уже внедрены в соответствующие разделы документа.

### Приоритеты реализации

| Фаза | Функционал | Сложность |
|------|------------|-----------|
| 1 | Граф участников (просмотр) + базовые фильтры | Низкая |
| 2 | Детали узла/ребра в правой панели | Низкая |
| 3 | Запуск симуляции (random market) | Средняя |
| 4 | Метрики в реальном времени | Средняя |
| 5 | Дополнительные сценарии и профили | Высокая |

### Архитектурные улучшения (после MVP)

1. **Отделить генератор сценариев от визуализации** — симулятор может быть CLI-утилитой на Python, которая генерирует трафик. Визуализатор — отдельное веб-приложение, которое читает состояние через API.

2. **WebSocket для real-time обновлений** — вместо polling использовать WebSocket для мгновенного обновления графа при изменениях.

3. **Кэширование состояния графа** — хранить последнее состояние сети в Redis/памяти для быстрого ответа на запросы визуализатора.

### UX-улучшения (после MVP)

1. **Подсказки при первом запуске** — короткий onboarding (3–4 шага) объясняющий что такое trustline, долг, клиринг.

2. **Режим «фокус на участнике»** — при выборе узла автоматически скрывать несвязанные с ним узлы (режим ego-graph).

3. **Анимация платежей** — при выполнении платежа показывать анимацию «потока» по маршруту.

4. **Сравнение снапшотов** — возможность сравнить состояние сети в два момента времени (diff-view).

---

## 13. Интеграция ИИ в симулятор сценариев и поведения

> Цель: дать пользователю возможность **естественным языком** задавать мир, поведение и «перекосы» в экосистеме GEO, а ИИ — автоматически превращать это в строгую конфигурацию сценария, применимую к симулятору.

### 13.1. Роль ИИ и общая архитектура

ИИ не заменяет ядро симуляции, а выступает как **«компилятор» сценариев**:

- на вход: текстовое описание от пользователя;
- на выход: JSON/DSL‑сценарий с:
  - участниками;
  - линиями доверия;
  - профилями поведения;
  - событиями и стресс‑сценариями.

**Компоненты:**

1. **Simulation Core** (уже описан ранее):
   - читает конфигурацию мира (JSON/DSL);
   - крутит симуляцию (tick‑based или event‑based);
   - общается с реальным GEO API.

2. **Scenario Config Store**:
   - хранит сценарии и их версии (`scenarioId`, `version`);
   - хранит seed генераторов случайных чисел для воспроизводимости;
   - хранит метаданные: автор, запрос пользователя, модель ИИ.

3. **AI Scenario & Behavior Engine (новый сервис)**:
   - REST/gRPC‑API:
     - `POST /ai/scenario-from-text` — создать сценарий по описанию;
     - `POST /ai/patch-from-text` — сгенерировать патч к текущему сценарию;
     - `POST /ai/explain-current-state` — текстовое объяснение состояния сети и «узких мест»;
     - `POST /ai/generate-stress-scenarios` — набор стресс‑сценариев для данного мира;
     - `POST /ai/recommend-crisis-actions` — рекомендации по антикризисным действиям на основе текущего состояния и целей.
   - внутри — LLM + слой пост‑обработки, который приводит ответы к жёсткой схеме.

4. **UI (React‑клиент симулятора)**:
   - панель ИИ‑ассистента:
     - поле ввода текста;
     - кнопки: «Сгенерировать сценарий», «Применить изменения», «Объяснить, что происходит», «Предложить стресс‑тесты», «Предложить план выхода из кризиса»;
   - остальной UI — как уже описано в спецификации (граф, фильтры, метрики и т.д.).

### 13.2. Формат сценария (DSL/JSON), с которым работает ИИ

Чтобы ИИ можно было надёжно интегрировать, нужен **простой формальный формат сценария**.

Пример базовой структуры (JSON):

```json
{
  "participants": [
    {
      "id": "p1",
      "name": "Иван",
      "type": "person",
      "groupId": "A",
      "behaviorProfileId": "normal_consumer"
    },
    {
      "id": "h1",
      "name": "Магазин у дома",
      "type": "hub",
      "groupId": "center",
      "behaviorProfileId": "merchant"
    }
  ],
  "trustlines": [
    { "from": "p1", "to": "h1", "limit": 1000 },
    { "from": "p2", "to": "p3", "limit": 300 }
  ],
  "behaviorProfiles": [
    {
      "id": "normal_consumer",
      "props": {
        "riskTolerance": 0.5,
        "trustPropensity": 0.5,
        "panicSensitivity": 0.3,
        "hoardingTendency": 0.4,
        "localismBias": 0.6
      },
      "rules": [
        {
          "trigger": "each_day",
          "action": "random_payment_within_cluster",
          "params": { "avgAmount": 100, "variance": 0.3 }
        }
      ]
    },
    {
      "id": "panic_prone",
      "extends": "normal_consumer",
      "props": {
        "panicSensitivity": 0.9,
        "hoardingTendency": 0.7
      },
      "rules": [
        {
          "trigger": "metric_drop(network_success_rate,0.8)",
          "action": "reduce_outgoing_payments",
          "params": { "factor": 0.5 }
        }
      ]
    }
  ],
  "groups": [
    { "id": "A", "label": "Район А" },
    { "id": "B", "label": "Район B" },
    { "id": "center", "label": "Центральные хабы" }
  ],
  "events": [
    {
      "time": "day_10",
      "type": "stress",
      "description": "Паника в районе B",
      "effects": [
        { "targetGroup": "B", "applyBehaviorProfile": "panic_prone" }
      ]
    }
  ]
}
```

**Задача ИИ:** из естественного описания:

> «200 участников, три района с сильной клановостью, 5 магазинов‑хабов, 10% паникёров, периодические вспышки спроса…»

собрать такой JSON:
- сгенерировать `participants` (количество, типы, привязка к группам);
- сгенерировать `trustlines` (сильные связи внутри групп, слабые между);
- создать `behaviorProfiles` для «нормальных», «паникёров», «накопителей» и т.п.;
- добавить `events` (например, «паника в районе B в день 10»).

### 13.3. Взаимодействие пользователя с ИИ (UX‑потоки)

#### 13.3.1. Создание сценария «с нуля» по тексту

1. В левой панели или TopBar добавляется блок **«ИИ‑сценарист»**:

   - многострочное поле:
     > «Опишите, что вы хотите смоделировать…»
   - пример подсказки:
     > «Смоделируй город из 3 районов, всего ~200 участников.  
     > Внутри районов доверие сильное, между районами слабое.  
     > 5 магазинов‑хабов, один из них более дорогой.  
     > 10% людей — паникёры, 20% — склонны к накопительству.»

2. Пользователь жмёт **«Сгенерировать сценарий»**.

3. UI → `POST /ai/scenario-from-text`:

   ```json
   {
     "prompt": "…текст пользователя…",
     "constraints": {
       "maxParticipants": 300,
       "baseEquivalent": "UAH"
     }
   }
   ```

4. AI‑сервис:
   - генерирует сценарий (как в примере выше);
   - возвращает:
     - `scenario` (JSON);
     - `summary` — краткое резюме.

5. UI:
   - подсвечивает резюме:
     - «Создано участников: 212 (person: 190, organization: 17, hub: 5)»
     - «Районы: A, B, C; клановость внутри районов высокая»
     - «Профили поведения: normal_consumer (70%), hoarder (20%), panic_prone (10%)»
   - отображает граф в `GraphView` как обычно;
   - даёт кнопку **«Запустить симуляцию»**.

Пользователь **не настраивает десятки параметров вручную** — всё задаётся описанием на естественном языке.

#### 13.3.2. Интерактивные изменения по ходу симуляции

Во время работы симуляции пользователь может:

- изменить поведение:
  > «Сделай район C более клановым и добавь несколько спекулянтов на стыке районов A и B.»

- изменить структуру доверия:
  > «Сократи лимиты доверия между районами до 50%, но оставь внутри районов как есть.»

UI отправляет это в `POST /ai/patch-from-text`, а результатом становится JSON‑патч (см. 13.4).

---

### 13.4. Патчи по тексту (динамическая коррекция сценария)

**Цель:** позволить пользователю корректировать мир короткими текстовыми командами, не переписывая весь сценарий.

#### 13.4.1. Формат патча

Пример логического формата (до применения к конкретным ID):

```json
{
  "op": "update",
  "participants": [
    {
      "filter": { "groupId": "C", "type": "person" },
      "set": { "behaviorProfileId": "clan_localist" }
    }
  ],
  "trustlines": [
    {
      "filter": { "fromGroup": "A", "toGroup": "B" },
      "scaleLimitBy": 0.5
    }
  ],
  "behaviorProfiles": [
    {
      "id": "clan_localist",
      "props": {
        "localismBias": 0.95,
        "trustPropensity": 0.3
      },
      "rules": [
        {
          "trigger": "each_day",
          "action": "prefer_payments_within_group",
          "params": { "probability": 0.9 }
        }
      ]
    }
  ]
}
```

После пост‑обработки AI‑сервис разворачивает фильтры в конкретные изменения (список ID), и сохраняется новая версия сценария.

#### 13.4.2. Пример текст → патч

Текст пользователя:

> «Усиль клановость в районе C и сократи лимиты доверия между C и остальными на 30%.»

AI‑сервис:

- создаёт/правит `behaviorProfile` `clan_localist`;
- для всех `participants` с `groupId="C"` меняет профиль поведения;
- применяет `scaleLimitBy: 0.7` ко всем `trustlines`, где `fromGroup="C"` или `toGroup="C"`, но `otherGroup != "C"`.

С точки зрения пользователя:
- он ввёл простую фразу;
- через 1–2 секунды граф изменился (толщина межрайонных связей упала, участники C получили другой цвет/иконку профиля и т.п.).

---

### 13.5. Объяснение текущего состояния («почему здесь узкое место»)

**Цель:** дать ИИ‑комментарий поверх уже существующей визуализации и метрик.

#### 13.5.1. API

`POST /ai/explain-current-state`:

```json
{
  "snapshot": {
    "nodes": [...],
    "links": [...],
    "metrics": {
      "successRate": 0.76,
      "avgRouteLength": 3.2,
      "totalDebt": 120000,
      "clearingVolume": 45000,
      "bottlenecks": [
        { "participantId": "h1", "reason": "high_centrality_and_debt" },
        { "participantId": "p57", "reason": "over_trusted" }
      ]
    }
  },
  "question": "Почему у нас столько отказов и где узкие места?"
}
```

`snapshot` может быть:
- либо агрегированным (только метрики + топ‑узлов/рёбер),
- либо выборочным (выбранный район/кластер).

#### 13.5.2. Ответ ИИ (пример)

В сжатом виде:

> 1. Участник **h1 (крупный магазин)** является явным узким местом:  
>    - на нём замыкается 34% всех маршрутов,  
>    - он аккумулирует 41% общего долга,  
>    - многие маршруты длиной 3+ проходят через него.  
>    Это повышает вероятность отказов при исчерпании лимитов.
>
> 2. Участник **p57** имеет профиль поведения, близкий к «over‑trust»:
>    - он открыл 12 trustlines с высокими лимитами,
>    - при этом сам является должником в 9 из них.  
>    Это создаёт риск локальной нестабильности в его окрестности.
>
> 3. Отказы по платежам в основном возникают из‑за:
>    - недостатка лимита на рёбрах `cluster B ↔ cluster C`,
>    - отсутствия альтернативных маршрутов в обход `h1`.

UI может показать это как:
- текстовый отчёт от ИИ;
- подсветку на графе узких мест и проблемных связей (используя已有 режимы визуализации).

---

### 13.6. Авто‑генерация стресс‑сценариев

**Цель:** давать пользователю «набор кнопок» для быстрой проверки устойчивости сети под типовыми шоками, без ручного моделирования.

#### 13.6.1. Типовая таксономия стресс‑сценариев

ИИ может работать с набором паттернов:

- **Liquidity shock / отток ликвидности**:
  - часть участников резко снижает лимиты;
  - повышенная склонность к накопительству.

- **Panic episode / эпизод паники**:
  - резкое падение доверия в одном кластере;
  - массовое закрытие trustlines.

- **Hub failure / отказ хаба**:
  - выключение / «suspended» 1–2 центральных узлов;
  - перераспределение маршрутов.

- **Credit crunch / кредитное сжатие**:
  - общее снижение доступных лимитов по сети;
  - рост отказов по «нет маршрута/недостаток лимита».

#### 13.6.2. API

`POST /ai/generate-stress-scenarios`:

```json
{
  "baseScenario": { "...": "..." },
  "preferences": {
    "maxScenarios": 3,
    "focus": "trust_network_stability"
  }
}
```

Ответ:

```json
{
  "scenarios": [
    {
      "id": "stress_liquidity_shock_cluster_B",
      "label": "Отток ликвидности в кластере B",
      "description": "Резкое снижение лимитов и рост накопительства в районе B.",
      "patch": {
        "events": [
          {
            "time": "day_15",
            "type": "stress",
            "description": "Liquidity shock in cluster B",
            "effects": [
              {
                "targetGroup": "B",
                "applyBehaviorProfile": "hoarder",
                "scaleTrustlinesBy": 0.6
              }
            ]
          }
        ]
      }
    },
    {
      "id": "stress_hub_failure_h1",
      "label": "Отказ крупнейшего хаба h1",
      "description": "Выключение хаба h1 на 5 дней.",
      "patch": {
        "events": [
          {
            "time": "day_10",
            "type": "stress",
            "description": "Hub h1 suspended",
            "effects": [
              { "targetParticipantId": "h1", "setStatus": "suspended" }
            ]
          },
          {
            "time": "day_15",
            "type": "recovery",
            "description": "Hub h1 back online",
            "effects": [
              { "targetParticipantId": "h1", "setStatus": "active" }
            ]
          }
        ]
      }
    }
  ]
}
```

#### 13.6.3. UX

В UI (например, на вкладке «Metrics» или в правой панели) появляется секция:

- «Стресс‑сценарии, предложенные ИИ»:
  - список карт:
    - название;
    - краткое описание;
    - кнопки: «Просмотреть патч», «Запустить стресс‑тест».

При выборе сценария:

- граф визуализирует **до/после** (например, через «призрачные» рёбра/узлы);
- пользователь запускает симуляцию с учётом этого события на определённом шаге.

---

### 13.7. Рекомендации по антикризисным действиям

**Цель:** позволить ИИ не только диагностировать проблемы и генерировать стресс‑сценарии, но и **предлагать конкретные планы действий** (патчи) для выхода из кризисных ситуаций на уровне сообщества или отдельных кластеров.

#### 13.7.1. API

`POST /ai/recommend-crisis-actions`:

```json
{
  "snapshot": {
    "nodes": [...],
    "links": [...],
    "metrics": {
      "successRate": 0.62,
      "avgRouteLength": 4.1,
      "totalDebt": 180000,
      "clearingVolume": 30000,
      "bottlenecks": [
        { "participantId": "h1", "reason": "high_centrality_and_debt" },
        { "participantId": "cluster_B", "reason": "liquidity_shortage" }
      ]
    }
  },
  "goals": {
    "targetSuccessRate": 0.8,
    "maxAvgRouteLength": 3.0,
    "timeHorizonDays": 10
  },
  "constraints": {
    "maxChangedParticipants": 50,
    "maxTrustlineChangeFactor": 0.5,
    "allowSuspendHubs": true
  }
}
```

- `snapshot` — текущее состояние сети и ключевые метрики (как в 13.5), плюс, при необходимости, информация о уже активных стресс‑сценариях.
- `goals` — желаемые целевые значения метрик и горизонт времени (например, за 10 «дней» симуляции).
- `constraints` — операционные ограничения:
  - сколько участников допустимо затронуть;
  - насколько сильно можно менять лимиты (scale‑фактор);
  - можно ли временно выключать хабы и т.п.

**Ответ:**

```json
{
  "actionPlans": [
    {
      "id": "plan_diversify_h1",
      "label": "Разгрузка хаба h1 и диверсификация маршрутов",
      "description": "Снижение зависимости сети от единственного крупного хаба h1 за счёт расширения альтернативных маршрутов и поддержки периферийных узлов.",
      "patch": {
        "trustlines": [
          {
            "filter": { "to": "h1", "fromGroupNot": "center" },
            "scaleLimitBy": 0.7
          },
          {
            "filter": { "inCluster": true, "excludeHubs": true },
            "scaleLimitBy": 1.3
          }
        ],
        "behaviorProfiles": [
          {
            "id": "local_connector",
            "props": { "localismBias": 0.8, "trustPropensity": 0.6 },
            "rules": [
              {
                "trigger": "each_day",
                "action": "open_additional_intra_cluster_trustlines",
                "params": { "maxNewLinesPerDay": 2 }
              }
            ]
          }
        ],
        "participants": [
          {
            "filter": { "clusterId": "B", "type": "organization" },
            "set": { "behaviorProfileId": "local_connector" }
          }
        ]
      },
      "expectedImpact": {
        "successRate": { "delta": 0.12 },
        "avgRouteLength": { "delta": -0.4 },
        "concentrationIndex": { "delta": -0.25 }
      },
      "rationale": [
        "Снизим нагрузку на h1, уменьшая лимиты на его входящих trustlines.",
        "Укрепим связи внутри кластеров, чтобы платежи реже шли через центральный хаб.",
        "Назначим части организаций поведение 'локальных коннекторов', стимулирующее альтернативные маршруты."
      ],
      "simulationPreviewId": "sim_preview_123"
    }
  ]
}
```

- `actionPlans[]` — 2–5 альтернативных планов:
  - `patch` — в том же DSL, что и обычные патчи (см. 13.4);
  - `expectedImpact` — прогноз по ключевым метрикам (дельты);
  - `rationale` — объяснение предлагаемой стратегии;
  - `simulationPreviewId` — ID быстрого «what‑if» сценария (если был выполнен дополнительный прогон).

#### 13.7.2. Алгоритм работы ИИ

Внутри `AI Scenario & Behavior Engine`:

1. Анализируется `snapshot`:
   - метрики, узкие места, накопление долгов;
   - активные стресс‑сценарии (если есть).
2. Определяется тип кризиса:
   - перегрузка одного/нескольких хабов;
   - нехватка ликвидности в определённых кластерах;
   - чрезмерная концентрация долгов;
   - массовые отказы по «нет маршрута/недостаток лимита»;
   - панические поведения определённых групп.
3. Формируются шаблоны возможных интервенций:
   - структурные: перераспределение лимитов, добавление альтернативных trustlines;
   - поведенческие: смена профилей поведения (ограничение over‑trust, увеличение localismBias, усиление clearing‑поведенческих правил);
   - процедурные: более частый клиринг, мягкое снижение активности risk‑агентов.
4. Из этих шаблонов строятся конкретные `actionPlans` с учётом `constraints`.
5. (Опционально) по каждому плану запускается короткая дополнительная симуляция:
   - короткий горизонт (несколько «дней»/тик‑циклов);
   - оценка улучшения/ухудшения метрик;
   - результат попадает в `expectedImpact` и `simulationPreviewId`.

#### 13.7.3. UX: как планы попадают в интерфейс

- В **`AiInsightPanel`** (правый сайдбар):
  - при нажатии «Объяснить, что происходит» → помимо объяснения (13.5) отображается секция:
    - «Предлагаемые ИИ варианты действий»:
      - каждая карточка плана показывает:
        - заголовок;
        - краткое описание;
        - ключевой ожидаемый эффект (например: `+12% к successRate`, `-25% к концентрации долгов хаба h1`);
        - статусы достижения целей (иконки/цвета).
      - кнопки:
        - `Смоделировать план` — запускает отдельный прогон с этим патчем (new scenarioId);
        - `Применить к текущей симуляции` — отправляет `patch` в backend (после явного подтверждения).
- На вкладке **`Metrics`**:
  - кнопка `Предложить план выхода из кризиса`:
    - вызывает `POST /ai/recommend-crisis-actions`;
    - результаты отображаются в виде ряда карточек (как выше);
    - можно включить «превью» плана в `MainCanvas` (условная визуализация будущих изменений).

Важно: ИИ **никогда не применяет планы автоматически** — он только предлагает, пользователь подтверждает.

---

### 13.8. Минимальный план внедрения ИИ

1. **Сформировать и задокументировать схему сценария** (как в 13.2):
   - `participants`, `trustlines`, `behaviorProfiles`, `groups`, `events`.

2. **Добавить в backend симулятора API для работы со сценариями:**
   - `POST /scenario` — загрузка полного сценария;
   - `POST /scenario/:id/patch` — применение патча;
   - `POST /run` — запуск симуляции по `scenarioId`.

3. **Реализовать простой AI‑сервис (первый шаг):**
   - только `POST /ai/scenario-from-text`;
   - LLM + валидация JSON по схеме;
   - логирование: текст запроса, сгенерированный сценарий, модель ИИ, seed.

4. **Добавить в UI панель ИИ‑сценариста:**
   - многострочное поле ввода;
   - кнопка «Сгенерировать сценарий»;
   - показ резюме и графа перед запуском.

5. **Расширить AI‑сервис:**
   - добавить `patch-from-text`;
   - добавить `explain-current-state`;
   - добавить `generate-stress-scenarios`;
   - добавить `recommend-crisis-actions` (предложения по антикризисным действиям).

6. **Расширить UI:**
   - быстрые кнопки: «Уточнить поведение», «Объяснить, где узкие места», «Предложить стресс‑тесты», «Предложить план выхода из кризиса»;
   - отображение ответов ИИ поверх уже существующих визуализаций (подсветка, фильтры, объясняющий текст);
   - интеграция планов действий в `AiInsightPanel` и на вкладке `Metrics` с возможностью безопасного применения патчей.

---

## Заключение

Данный документ описывает полнофункциональный симулятор-визуализатор для сети GEO. Для MVP рекомендуется начать с базового графа и постепенно добавлять функционал по мере необходимости.

**Минимальный жизнеспособный продукт:**

1. Веб-страница с графом участников
2. Правая панель с деталями
3. Кнопка «запустить симуляцию» (random market)
4. 3–4 ключевых метрики

Это можно реализовать за 2–3 недели с использованием React + react-force-graph + MUI.

В качестве следующего шага развития поверх MVP предлагается слой ИИ‑интеграции (раздел 13), который позволит:
- задавать конфигурации мира и поведения естественным языком,
- автоматически генерировать и изменять сценарии (патчи),
- получать объяснения текущего состояния сети и узких мест,
- автоматически конструировать стресс‑сценарии для тестирования устойчивости протокола GEO,
- а также получать **конкретные планы антикризисных действий**, которые можно безопасно протестировать на симуляции и при необходимости частично перенести в реальные политики протокола.
