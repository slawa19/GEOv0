# Спецификация: Network Economy Analyzer (online) для Simulator UI

**Версия:** 1.0  
**Дата:** 2026-02-01  
**Статус:** Draft

---

## 1. Идея (простыми словами)

**Network Economy Analyzer** — это слой поверх симулятора, который в реальном времени:
- комментирует, *что происходит с экономикой сети* (а не только «что сломалось»);
- объясняет причины «человеческими» экономическими формулировками;
- предлагает конкретные действия администратору (регулятору/модератору) и подсказки по настройке сценария;
- показывает «доказательства» (метрики/бутылочные горлышки/коды отказов), чтобы можно было проверить вывод.

Ключевой принцип: **сначала человеко‑экономический смысл**, потом *техподробности* (коды, метрики, объекты backend).

---

## 2. Scope / Non‑goals

### 2.1 В scope (MVP)
- Real-time «инсайты» (insights) по сети и её работоспособности.
- Минимальный UX:
  - индикатор/счётчик инсайтов на HUD;
  - drawer (панель деталей) со списком инсайтов и раскрытием каждого.
- Дедупликация/TTL, чтобы не заспамить пользователя.
- Объяснимость: у каждого инсайта есть **evidence**.

### 2.2 Не в scope (пока)
- «AI/LLM анализ» и генерация свободного текста.
- Автоматические изменения trustlines/профилей без подтверждения.
- Универсальная аналитика «на все случаи»: MVP — набор правил/эвристик, расширяемый конфигом.

---

## 3. Входные данные (использовать как есть)

Analyzer в MVP не требует новых контрактов backend.

### 3.1 Реaltime stream (SSE)
События, которые уже идут в UI:
- `run_status` (включая `last_error`, counters)
- `tx.updated`, `tx.failed`
- `clearing.done`

Практически полезные агрегаты на стороне UI:
- `runStats` (attempts/committed/rejected/errors/timeouts + распределение по error.code).

### 3.2 Metrics / Bottlenecks (REST)
Используются периодическим polling (например, раз в 2–5 секунд, когда run active):
- `GET /simulator/runs/{run_id}/metrics`
  - ключи (сейчас): `success_rate`, `avg_route_length`, `total_debt`, `clearing_volume`, `bottlenecks_score`
- `GET /simulator/runs/{run_id}/bottlenecks`
  - `items[]` с `reason_code`, `label`, `suggested_action`, и `target` (edge)

### 3.3 Artifacts (для расследования)
- `events.ndjson`, `status.json`, `summary.json`, bundle.zip.

Analyzer не обязан читать artifacts в realtime, но должен **ссылаться на них** как на «следующее действие».

---

## 4. Выход: модель Insight

Analyzer порождает поток/список `Insight`.

### 4.1 Внешний контракт (UI‑internal в MVP)
```ts
type InsightSeverity = 'info' | 'warn' | 'critical'

type Insight = {
  id: string               // детерминированный, для дедупа
  kind: string             // семантический тип проблемы
  severity: InsightSeverity
  title: string            // коротко, по-человечески
  summary: string          // 1–2 предложения, экономический смысл

  createdAtMs: number
  ttlMs: number

  evidence: {
    // что именно наблюдаем (срез)
    metrics?: Array<{ key: string; v?: number; window?: string }>
    topBottlenecks?: Array<{ from: string; to: string; reason_code: string; score: number }>
    txFailedTopCodes?: Array<{ code: string; share: number; count: number }>
  }

  recommendations: {
    // порядок важен: сначала «вмешательство админа», затем «настройка сценария/параметров»
    adminActions: string[]
    scenarioActions?: string[]
    technicalNotes?: string[]
  }
}
```

### 4.2 Дедупликация/TTL
- `id` строится из `(kind + equivalent + primaryTarget + window)`.
- Один и тот же `kind` не должен всплывать чаще, чем раз в `cooldownMs` (например 30–90с).
- При повторном срабатывании можно:
  - обновить существующий инсайт (refresh evidence),
  - либо поднять severity (warn → critical),
  - но не создавать бесконечную очередь.

---

## 5. UX спецификация (минимальная)

### 5.1 Где живёт
- Real mode HUD уже показывает `run_status` и счётчики.
- Добавляем рядом кнопку/чип: **“Insights (N)”**.
- Клик открывает drawer справа (или снизу на узких экранах).

### 5.2 Drawer
Содержимое:
- заголовок: “Network Insights”
- фильтры: severity (all / warn+ / critical)
- список карточек:
  - `severity` badge
  - `title`
  - `summary` (экономический смысл)
  - кнопка “Details” (раскрывает блок)

В Details:
- **Что это значит** (1–3 предложения)
- **Доказательства** (метрики/коды/топ bottlenecks)
- **Почему так бывает** (короткий список причин)
- **Что сделать администратору** (порядок: быстрое → системное)
- **Технические детали** (спойлер/моно): коды, ключи метрик, ссылки на artifacts.

### 5.3 Политика тона
- `info`: «наблюдение/тенденция», без ощущения аварии.
- `warn`: «мешает экономике/проходимости», требует вмешательства.
- `critical`: «run почти бесполезен / сеть деградирует / системная блокировка».

---

## 6. Каталог проблем (rules)

Ниже — MVP набор (расширяемый). У каждой проблемы: **сигналы → трактовка → действия**.

### 6.1 Недостаток ликвидности на ключевых рёбрах (LOW_AVAILABLE)
**Сигналы:**
- `bottlenecks.items[].reason_code == LOW_AVAILABLE` у топ‑рёбер
- падение `success_rate`

**Экономический смысл:**
- «Деньги/кредит в нужном направлении закончились: торговля упирается в несколько лимитов».

**Рекомендации:**
- adminActions:
  - «Поднять лимиты на ключевых доверительных линиях (там, где реально идёт поток)»
  - «Добавить альтернативные маршруты (ещё 1–2 trustlines, чтобы не зависеть от одного ребра)»
- scenarioActions:
  - «Снизить интенсивность или распределить спрос между группами»

### 6.2 Перегрузка клиринга / “clearing pressure”
**Сигналы:**
- рост `total_debt` при слабом росте `clearing_volume`
- частые `clearing.done` без стабилизации `success_rate`

**Экономический смысл:**
- «Долги накапливаются быстрее, чем сеть успевает их “сжигать” клирингом».

**Рекомендации:**
- adminActions:
  - «Проверить, где образуются циклы клиринга: есть ли они вообще и какие узлы в них входят»
  - «Поддержать появление циклов: добавить недостающие рёбра, чтобы долги могли замыкаться»
- technicalNotes:
  - «Проверить cadence: `SIMULATOR_CLEARING_EVERY_N_TICKS` и лимиты глубины клиринга»

### 6.3 Сеть слишком “глубокая” (ROUTING_TOO_DEEP / высокий avg_route_length)
**Сигналы:**
- устойчиво высокий `avg_route_length` (например > 4–6)
- bottleneck причины типа `ROUTING_TOO_DEEP` (если/когда появится) или косвенно: рост отказов при росте route length

**Экономический смысл:**
- «Чтобы совершить платёж, нужно пройти слишком длинную цепочку доверия — сеть не локальна, а “лабиринт”».

**Рекомендации:**
- adminActions:
  - «Добавить “хабы доверия” или прямые рёбра между часто взаимодействующими кластерами»
  - «Уменьшить зависимость от 1–2 мостов (дублировать мосты)»

### 6.4 Фрагментация: нет маршрутов (ROUTING_NO_ROUTE)
**Сигналы:**
- в `tx.failed` доминирует `ROUTING_NO_ROUTE`
- `success_rate` низкий, а `LOW_AVAILABLE` не доминирует

**Экономический смысл:**
- «Часть участников экономически изолирована — доверительные пути не связаны».

**Рекомендации:**
- adminActions:
  - «Добавить 1–3 “моста” (trustlines) между компонентами графа»
  - «Проверить направление trustlines: не “перевёрнуты” ли ключевые связи»
- scenarioActions:
  - «Проверить equivalents: платежи и trustlines должны быть в одном equivalent»

### 6.5 Низкая пропускная способность из‑за таймаутов (TOO_MANY_TIMEOUTS / PAYMENT_TIMEOUT)
**Сигналы:**
- рост `timeouts` в `runStats`
- `bottlenecks.reason_code == TOO_MANY_TIMEOUTS`
- падение `ops_sec`, рост `queue_depth` (если доступно в run_status)

**Экономический смысл:**
- «Сеть вроде бы может проводить платежи, но инфраструктура не успевает: сделки “застревают”».

**Рекомендации:**
- adminActions:
  - «Снизить интенсивность (сделки реже) и сравнить метрики»
  - «Проверить DB/Redis, блокировки, нагрузку»
- technicalNotes:
  - «SQLite в real mode часто проявляет локи/таймауты, лучше Postgres+Redis»

### 6.6 Частые отказы/аборты (FREQUENT_ABORTS / HIGH_USED)
**Сигналы:**
- bottlenecks: `FREQUENT_ABORTS`, `HIGH_USED`
- `success_rate` не растёт при росте попыток

**Экономический смысл:**
- «Сеть перегрета: многие пытаются пройти по одним и тем же каналам, и сделки конкурируют».

**Рекомендации:**
- adminActions:
  - «Диверсифицировать маршруты: добавить рёбра рядом с перегруженными»
  - «Увеличить лимиты в направлении основного потока»

### 6.7 “Плохой баланс”: долг концентрируется у малого числа узлов
**Сигналы:**
- рост `total_debt`
- (опционально) из snapshot видно, что `net_sign` сильно отрицательный у нескольких узлов

**Экономический смысл:**
- «Сеть создаёт “чёрные дыры долга”: несколько участников постоянно потребляют кредит, не возвращая через цикл».

**Рекомендации:**
- adminActions:
  - «Ограничить лимиты для хронических должников / ввести встречные потоки (контракты/заказы)»
  - «Сделать “возвратные” связи: чтобы долг мог замкнуться через клиринг»

### 6.8 Конфигурационная ошибка: эквиваленты/направления
**Сигналы:**
- систематические отказы типа “limit exceeded / not active / sender not found” (если есть)
- массовый `ROUTING_NO_ROUTE` при визуально “связанном” графе

**Экономический смысл:**
- «Не экономика, а настройка: сеть задана так, что сделки не могут быть валидными».

**Рекомендации:**
- scenarioActions:
  - «Проверить инвариант направления: `from → to` = creditor → debtor»
  - «Проверить: `trustlines[].equivalent` ∈ `equivalents[]`»
  - «В real mode: участники должны существовать в БД (сидирование)»

---

## 7. Алгоритм (MVP, UI‑side)

### 7.1 Тайминг
- Analyzer живёт в real mode вместе с SSE loop.
- Каждые `pollMs` (2–5 сек) делает:
  - fetch metrics
  - fetch bottlenecks
- На каждый «шаг» строит features:
  - текущий success_rate (последняя точка)
  - delta успеха за окно 30–60с
  - top bottlenecks (score)
  - top tx.failed codes (из runStats)

### 7.2 Правила
- Правила — чистые функции `(features, state) -> Insight | null`.
- Пороговые значения задаются в одном месте (конфиг), чтобы было легко калибровать.

### 7.3 Дедуп/эскалация
- Если инсайт с тем же `id` уже активен:
  - обновить evidence
  - при ухудшении — поднять severity

---

## 8. Интеграция в код (органично)

### 8.1 Simulator UI v2 (предпочтительный MVP)
Добавить:
- composable: `useNetworkEconomyAnalyzer.ts`
  - вход: `runId`, `runStatus`, `runStats`, api client
  - выход: `insights[]`, `unreadCount`, `open/close drawer`
- UI:
  - HUD: кнопка/чип `Insights (N)` рядом с существующими badge/статами
  - `InsightsDrawer.vue` как overlay‑panel (по аналогии с существующими overlays)

Важно: UX должен быть совместим с текущим паттерном `hud-alert` и overlay в root.

### 8.2 Backend (позже, если нужно)
Когда понадобится консистентность и шаринг инсайтов:
- добавить генерацию инсайтов на backend на основе тех же метрик/бутылочных горлышек
- варианты выдачи:
  1) новый SSE event `insight.created`
  2) endpoint `GET /simulator/runs/{run_id}/insights`

Backend‑вариант позволяет:
- хранить историю инсайтов в БД
- отдавать одинаковые результаты всем клиентам
- использовать инсайты в отчетах/артефактах

---

## 9. Acceptance criteria (MVP)

- Во время real mode run пользователь видит `Insights (N)` на HUD.
- Drawer показывает минимум 3–5 типов инсайтов из каталога (см. раздел 6).
- Каждый инсайт содержит evidence (метрики/коды/топ bottlenecks).
- Нет спама: дедуп/TTL работает (не более 1 инсайта одного типа в окно cooldown).
- Тексты сначала «экономические», затем технические детали (в спойлере).
