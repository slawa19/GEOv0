# GEO — Приложение‑симулятор поведения пользователей

> Спецификация приложения для симуляции и тестирования поведения «живого сообщества» в сети GEO (описание UI/визуализации вынесено в отдельные спецификации)

---

## Оглавление

1. [Введение](#1-введение)
2. [Основной функционал симулятора](#2-основной-функционал-симулятора)
   - 2.1. [Конфигурация «мира»](#21-конфигурация-мира-генерация-сети)
   - 2.2. [Поведенческие сценарии](#22-поведенческие-сценарии-модели-взаимодействия)
   - 2.3. [Управление нагрузкой](#23-управление-нагрузкой)
   - 2.4. [Взаимодействие с API ядра](#24-взаимодействие-с-реальным-api-ядра)
3. [Аналитика и наблюдаемость](#3-аналитика-и-наблюдаемость)
  - 3.1. [Агрегированные метрики](#31-агрегированные-метрики-во-времени)
  - 3.2. [Показатели эффективности протокола](#32-показатели-эффективности-протокола)
  - 3.3. [Реплей и сравнение прогонов](#33-реплей-и-сравнение-прогонов)
4. [Настройки и сценарии для ТЗ](#4-настройки-и-сценарии-для-тз)
5. [Рекомендуемый технический стек](#5-рекомендуемый-технический-стек)
6. [Рекомендации по улучшению приложения](#6-рекомендации-по-улучшению-приложения)
7. [Интеграция ИИ в симулятор сценариев и поведения](#7-интеграция-ии-в-симулятор-сценариев-и-поведения)

---

## 1. Введение

**Отдельное приложение, которое имитирует живое сообщество** и нагружает ядро GEO. Это одновременно:

- генератор трафика и сценариев поведения;
- инструмент нагрузочного тестирования;
- лаборатория для экспериментов с протоколом (routing, clearing, политики доверия).

> UI/визуализация симулятора описаны отдельно:
> - `docs/ru/simulator/frontend/docs/specs/Игровой интерфейс симулятора GEO.md`
> - `docs/ru/simulator/frontend/docs/specs/10-visual-demo-fast-mock.md`

### Общая идея

Приложение подключается к API hub'а как множество «виртуальных пользователей» (участников), создаёт и управляет ими, открывает между ними trustlines, генерирует платежи, инициирует/реагирует на клиринг. По сути, это **симуляция экономики сообщества** поверх реального ядра GEO.

**Цели:**

- проверить производительность и устойчивость реализации;
- проверить корректность логики (особенно клиринга, ограничений лимитов, идемпотентности);
- исследовать, как разные топологии доверия и модели поведения влияют на:
  - эффективность взаимозачетов;
  - распределение долгов/кредитов;
  - среднюю длину маршрутов и частоту отказов;
- находить баги и узкие места ещё до того, как система попадёт к реальным пользователям.

---

## 2. Основной функционал симулятора

### 2.1. Конфигурация «мира» (генерация сети)

> **MVP-подход:** Начать с JSON-конфигурации (список участников + список trustlines). Динамическую генерацию добавить позже.

Возможность задать параметры сети через JSON-файл:

```json
{
  "participants": [
    { "id": "p1", "name": "Иван", "type": "person" },
    { "id": "p2", "name": "Кофейня", "type": "business" }
  ],
  "trustlines": [
    { "from": "p1", "to": "p2", "limit": 1000 }
  ]
}
```

Параметры конфигурации:

- количество участников;
- типы участников (обычные, «центральные» узлы, hubs и т.п.);
- список trustlines с указанием лимитов;
- **один эквивалент** (например, `UAH`) — для MVP этого достаточно.

Симулятор может:

- **загружать готовые JSON-сценарии** (основной режим для MVP);
- автоматически генерировать сеть (расширенный режим, добавить позже).

### 2.2. Поведенческие сценарии (модели взаимодействия)

Модели, которые описывают, как участники ведут себя во времени:

- **«случайный рынок»** — участники случайно выбирают друг друга и совершают платежи;
- **«кластерный обмен»** — более интенсивный обмен внутри подгрупп, редкий между ними;
- **«клиент‑поставщик»** — одни участники в основном продают, другие в основном покупают;
- **стресс‑сценарии**:
  - всплеск активности;
  - отключение части участников (suspended);
  - резкая смена лимитов trustlines.

Модели должны настраиваться:

- интенсивность транзакций (сколько платежей в секунду/минуту/час);
- распределение сумм платежей;
- вероятность изменения trustlines (увеличение/уменьшение лимитов, закрытие).

### 2.3. Управление нагрузкой

> **MVP-подход:** Один слайдер «интенсивность» (0–100%) вместо нескольких профилей.

Возможность динамически изменять:

- общее число активных «виртуальных пользователей»;
- **интенсивность симуляции** — один слайдер 0–100%:
  - 0% — симуляция на паузе;
  - 25% — спокойный день;
  - 50% — обычная нагрузка;
  - 75% — пиковый час;
  - 100% — стресс-тест.

Соотношение типов операций (для расширенного режима):

- сколько процентов — платежи;
- сколько — изменения trustlines;
- сколько — искусственно инициированные клиринги.

### 2.4. Взаимодействие с реальным API ядра

Симулятор не должен «лезть в БД напрямую», а использовать те же интерфейсы, что и реальные клиенты:

- регистрация участников через API;
- создание trustlines через API;
- отправка `PAYMENT_REQUEST` и ожидание результата;
- мониторинг состояний транзакций.

Это гарантирует, что мы тестируем именно протокольный слой и логику, а не только внутренние функции.

---

## 3. Аналитика и наблюдаемость

Цель этого раздела — определить, **какие данные симулятор должен собирать и выдавать**, чтобы проверять гипотезы про «живое сообщество», устойчивость протокола и воспроизводимость прогонов.

### 3.1. Агрегированные метрики во времени

> **MVP-подход:** Вместо 10+ метрик достаточно 4–5 ключевых.

**Ключевые метрики для MVP:**

| Метрика | Зачем |
|---------|-------|
| Общий объём долгов | Понять масштаб системы |
| % успешных платежей | Оценить работоспособность |
| Средняя длина маршрута | Оценить эффективность сети |
| Объём клиринга | Оценить работу взаимозачётов |
| Топ-5 «узких мест» | Найти перегруженных участников |

**Расширенные метрики (после MVP):**

- Распределение длины маршрутов (максимум);
- Частота отказов по причинам:
  - нет маршрута;
  - недостаток лимита;
  - таймаут 2PC.
- Графики по времени (time series), возможность перемотки/просмотра истории.

### 3.2. Показатели эффективности протокола

- **Эффективность взаимозачётов** — отношение суммы клиринга к сумме всех проведённых платежей;
- **Концентрация долгов** — какие участники становятся «узкими местами» (на них замыкается много долгов);
- **Стабильность сети** — как часто система приходит в состояния, когда новые платежи «не проходят» из‑за перегруженности определённых рёбер.

### 3.3. Реплей и сравнение прогонов

> ⚠️ **Не для MVP** — требует сложной сериализации состояния. Реализовать после базового функционала.

- Возможность записать сценарий (или фрагмент симуляции) и результаты прогона;
- Затем проигрывать его с разной скоростью (или пересчитывать с тем же seed/событиями);
- Сравнивать, как повели бы себя разные версии протокола/алгоритмов.

**Практичный MVP-вариант без «сложной сериализации состояния»:**

- логировать *входные события* (платежи/изменения trustlines/инициации clearing) с таймкодами;
- периодически сохранять *снапшоты состояния* (минимальный набор агрегатов + выборочные сущности);
- иметь инструмент *diff двух снапшотов* (что изменилось по метрикам и по ключевым сущностям).

---

## 4. Настройки и сценарии для ТЗ

В перспективе ТЗ для такого приложения может включать:

- **Ядро симуляции:**
  - движок сценариев (скриптовый язык или конфигурационные файлы);
  - генератор событий (tick‑based или event‑based).

- **Сценарные настройки:**
  - параметры генерации сети;
  - профили поведения участников;
  - планировщик событий (в какое время что меняется).

- **Поддержка реплики и воспроизводимости:**
  - фиксированные seed'ы для генераторов случайных чисел;
  - сохранение конфигураций и результатов прогонов.

- **Поддержка разных версий backend'а GEO:**
  - возможность запускать симуляцию против разных инстансов ядра (например, v0.1, v0.2).

Такое приложение станет не только инструментом тестирования, но и **исследовательской лабораторией** для развития протокола GEO.

---

## 5. Рекомендуемый технический стек

Этот документ описывает симуляцию и тестирование. UI/визуализация — в отдельных спецификациях (см. ссылки во введении).

**Принципы реализации:**

- детерминизм (seed + события) и воспроизводимость прогонов;
- одинаковый формат данных для mock-режима и real-режима (fixture/API parity);
- вычисления семантики/агрегатов — на стороне симулятора/бэкенда, а не в клиенте.

**Рекомендуемые компоненты:**

| Зона | Рекомендация | Зачем |
|------|-------------|-------|
| Формат сценария | JSON (+ JSON Schema) или простой DSL поверх JSON | Валидируемость и стабильность |
| Симулятор (runner) | Python 3.11+ (async) или Node.js | Быстрая итерация и интеграция с API |
| Клиент к GEO API | async HTTP + строгие таймауты, ретраи, идемпотентность | Реалистичная нагрузка |
| Хранилище прогонов | Файлы (NDJSON событий + снапшоты) + опционально SQLite/Postgres | Реплей и сравнение прогонов |
| Метрики | Сбор событий → агрегация в процессе/отдельным шагом | Наблюдаемость без UI-зависимости |
| Режимы запуска | CLI + конфиги | Автоматизация и CI |

---

## 6. Рекомендации по улучшению приложения

> Ниже — дополнительные улучшения, которые можно реализовать после MVP. Фокус — симуляция «живого сообщества», воспроизводимость и нагрузочное тестирование.

### Приоритеты реализации

| Фаза | Функционал | Сложность |
|------|------------|-----------|
| 1 | Загрузка сценариев (JSON/DSL) + валидация схемой | Низкая |
| 2 | Runner: платежи/изменения trustlines/clearing по расписанию | Средняя |
| 3 | Управление нагрузкой (интенсивность 0–100%) | Средняя |
| 4 | Метрики в реальном времени + периодические снапшоты | Средняя |
| 5 | Реплей/сравнение прогонов (seed + события + diff) | Высокая |
| 6 | Библиотека стресс‑сценариев (panic, credit crunch, hub failure, liquidity shock) | Высокая |

### Архитектурные улучшения (после MVP)

1. **Отделить генератор/runner от визуализации** — симулятор можно запускать как CLI/сервис, а любой UI-клиент лишь читает данные и отображает их.

2. **Поток событий вместо «полных состояний»** — события (NDJSON/WS) + снапшоты по интервалу дают и live-аналитику, и реплей.

3. **Стандартизировать артефакты прогона** — единый формат: `scenario.json`, `events.ndjson`, `snapshots/*.json`, `summary.json`, чтобы легко сравнивать версии протокола.

---

## 7. Интеграция ИИ в симулятор сценариев и поведения

> Цель: дать пользователю возможность **естественным языком** задавать мир, поведение и «перекосы» в экосистеме GEO, а ИИ — автоматически превращать это в строгую конфигурацию сценария, применимую к симулятору.

### 7.1. Роль ИИ и общая архитектура

ИИ не заменяет ядро симуляции, а выступает как **«компилятор» сценариев**:

- на вход: текстовое описание от пользователя;
- на выход: JSON/DSL‑сценарий с:
  - участниками;
  - линиями доверия;
  - профилями поведения;
  - событиями и стресс‑сценариями.

**Компоненты:**

1. **Simulation Core** (уже описан ранее):
   - читает конфигурацию мира (JSON/DSL);
   - крутит симуляцию (tick‑based или event‑based);
   - общается с реальным GEO API.

2. **Scenario Config Store**:
   - хранит сценарии и их версии (`scenarioId`, `version`);
   - хранит seed генераторов случайных чисел для воспроизводимости;
   - хранит метаданные: автор, запрос пользователя, модель ИИ.

3. **AI Scenario & Behavior Engine (новый сервис)**:
   - REST/gRPC‑API:
     - `POST /ai/scenario-from-text` — создать сценарий по описанию;
     - `POST /ai/patch-from-text` — сгенерировать патч к текущему сценарию;
     - `POST /ai/explain-current-state` — текстовое объяснение состояния сети и «узких мест»;
     - `POST /ai/generate-stress-scenarios` — набор стресс‑сценариев для данного мира;
     - `POST /ai/recommend-crisis-actions` — рекомендации по антикризисным действиям на основе текущего состояния и целей.
   - внутри — LLM + слой пост‑обработки, который приводит ответы к жёсткой схеме.

4. **Клиент симулятора (любой UI/CLI)**:
  - отправляет запросы к AI‑сервису;
  - получает `scenario`/`patch`/`summary` и применяет их к текущему прогону;
  - отображает отчёты ИИ как текст/таблицы/метрики.

  UI/визуализация описаны отдельно (см. ссылки во введении).

### 7.2. Формат сценария (DSL/JSON), с которым работает ИИ

Чтобы ИИ можно было надёжно интегрировать, нужен **простой формальный формат сценария**.

Пример базовой структуры (JSON):

```json
{
  "participants": [
    {
      "id": "p1",
      "name": "Иван",
      "type": "person",
      "groupId": "A",
      "behaviorProfileId": "normal_consumer"
    },
    {
      "id": "h1",
      "name": "Магазин у дома",
      "type": "hub",
      "groupId": "center",
      "behaviorProfileId": "merchant"
    }
  ],
  "trustlines": [
    { "from": "p1", "to": "h1", "limit": 1000 },
    { "from": "p2", "to": "p3", "limit": 300 }
  ],
  "behaviorProfiles": [
    {
      "id": "normal_consumer",
      "props": {
        "riskTolerance": 0.5,
        "trustPropensity": 0.5,
        "panicSensitivity": 0.3,
        "hoardingTendency": 0.4,
        "localismBias": 0.6
      },
      "rules": [
        {
          "trigger": "each_day",
          "action": "random_payment_within_cluster",
          "params": { "avgAmount": 100, "variance": 0.3 }
        }
      ]
    },
    {
      "id": "panic_prone",
      "extends": "normal_consumer",
      "props": {
        "panicSensitivity": 0.9,
        "hoardingTendency": 0.7
      },
      "rules": [
        {
          "trigger": "metric_drop(network_success_rate,0.8)",
          "action": "reduce_outgoing_payments",
          "params": { "factor": 0.5 }
        }
      ]
    }
  ],
  "groups": [
    { "id": "A", "label": "Район А" },
    { "id": "B", "label": "Район B" },
    { "id": "center", "label": "Центральные хабы" }
  ],
  "events": [
    {
      "time": "day_10",
      "type": "stress",
      "description": "Паника в районе B",
      "effects": [
        { "targetGroup": "B", "applyBehaviorProfile": "panic_prone" }
      ]
    }
  ]
}
```

**Задача ИИ:** из естественного описания:

> «200 участников, три района с сильной клановостью, 5 магазинов‑хабов, 10% паникёров, периодические вспышки спроса…»

собрать такой JSON:
- сгенерировать `participants` (количество, типы, привязка к группам);
- сгенерировать `trustlines` (сильные связи внутри групп, слабые между);
- создать `behaviorProfiles` для «нормальных», «паникёров», «накопителей» и т.п.;
- добавить `events` (например, «паника в районе B в день 10»).

### 7.3. Взаимодействие пользователя с ИИ (потоки)

#### 7.3.1. Создание сценария «с нуля» по тексту

1. Пользователь вводит текстовое описание того, что нужно смоделировать:

   - многострочное поле:
     > «Опишите, что вы хотите смоделировать…»
   - пример подсказки:
     > «Смоделируй город из 3 районов, всего ~200 участников.  
     > Внутри районов доверие сильное, между районами слабое.  
     > 5 магазинов‑хабов, один из них более дорогой.  
     > 10% людей — паникёры, 20% — склонны к накопительству.»

2. Клиент/CLI отправляет запрос на генерацию сценария.

3. Клиент → `POST /ai/scenario-from-text`:

   ```json
   {
     "prompt": "…текст пользователя…",
     "constraints": {
       "maxParticipants": 300,
       "baseEquivalent": "UAH"
     }
   }
   ```

4. AI‑сервис:
   - генерирует сценарий (как в примере выше);
   - возвращает:
     - `scenario` (JSON);
     - `summary` — краткое резюме.

5. Клиент:
  - показывает резюме:
    - «Создано участников: 212 (person: 190, business: 17, hub: 5)»
     - «Районы: A, B, C; клановость внутри районов высокая»
     - «Профили поведения: normal_consumer (70%), hoarder (20%), panic_prone (10%)»
  - предлагает **запустить прогон** (или сохранить сценарий).

Пользователь **не настраивает десятки параметров вручную** — всё задаётся описанием на естественном языке.

#### 7.3.2. Интерактивные изменения по ходу симуляции

Во время работы симуляции пользователь может:

- изменить поведение:
  > «Сделай район C более клановым и добавь несколько спекулянтов на стыке районов A и B.»

- изменить структуру доверия:
  > «Сократи лимиты доверия между районами до 50%, но оставь внутри районов как есть.»

Клиент отправляет это в `POST /ai/patch-from-text`, а результатом становится JSON‑патч (см. 7.4).

---

### 7.4. Патчи по тексту (динамическая коррекция сценария)

**Цель:** позволить пользователю корректировать мир короткими текстовыми командами, не переписывая весь сценарий.

#### 7.4.1. Формат патча

Пример логического формата (до применения к конкретным ID):

```json
{
  "op": "update",
  "participants": [
    {
      "filter": { "groupId": "C", "type": "person" },
      "set": { "behaviorProfileId": "clan_localist" }
    }
  ],
  "trustlines": [
    {
      "filter": { "fromGroup": "A", "toGroup": "B" },
      "scaleLimitBy": 0.5
    }
  ],
  "behaviorProfiles": [
    {
      "id": "clan_localist",
      "props": {
        "localismBias": 0.95,
        "trustPropensity": 0.3
      },
      "rules": [
        {
          "trigger": "each_day",
          "action": "prefer_payments_within_group",
          "params": { "probability": 0.9 }
        }
      ]
    }
  ]
}
```

После пост‑обработки AI‑сервис разворачивает фильтры в конкретные изменения (список ID), и сохраняется новая версия сценария.

#### 7.4.2. Пример текст → патч

Текст пользователя:

> «Усиль клановость в районе C и сократи лимиты доверия между C и остальными на 30%.»

AI‑сервис:

- создаёт/правит `behaviorProfile` `clan_localist`;
- для всех `participants` с `groupId="C"` меняет профиль поведения;
- применяет `scaleLimitBy: 0.7` ко всем `trustlines`, где `fromGroup="C"` или `toGroup="C"`, но `otherGroup != "C"`.

С точки зрения пользователя:
- он ввёл простую фразу;
- через 1–2 секунды сценарий обновился (а симулятор продолжил прогон с обновлёнными правилами либо запустил новый прогон).

---

### 7.5. Объяснение текущего состояния («почему здесь узкое место»)

**Цель:** дать ИИ‑комментарий по метрикам, снапшотам и наблюдаемым «узким местам».

#### 7.5.1. API

`POST /ai/explain-current-state`:

```json
{
  "snapshot": {
    "nodes": [...],
    "links": [...],
    "metrics": {
      "successRate": 0.76,
      "avgRouteLength": 3.2,
      "totalDebt": 120000,
      "clearingVolume": 45000,
      "bottlenecks": [
        { "participantId": "h1", "reason": "high_centrality_and_debt" },
        { "participantId": "p57", "reason": "over_trusted" }
      ]
    }
  },
  "question": "Почему у нас столько отказов и где узкие места?"
}
```

`snapshot` может быть:
- либо агрегированным (только метрики + топ‑узлов/рёбер),
- либо выборочным (выбранный район/кластер).

#### 7.5.2. Ответ ИИ (пример)

В сжатом виде:

> 1. Участник **h1 (крупный магазин)** является явным узким местом:  
>    - на нём замыкается 34% всех маршрутов,  
>    - он аккумулирует 41% общего долга,  
>    - многие маршруты длиной 3+ проходят через него.  
>    Это повышает вероятность отказов при исчерпании лимитов.
>
> 2. Участник **p57** имеет профиль поведения, близкий к «over‑trust»:
>    - он открыл 12 trustlines с высокими лимитами,
>    - при этом сам является должником в 9 из них.  
>    Это создаёт риск локальной нестабильности в его окрестности.
>
> 3. Отказы по платежам в основном возникают из‑за:
>    - недостатка лимита на рёбрах `cluster B ↔ cluster C`,
>    - отсутствия альтернативных маршрутов в обход `h1`.

Клиент симулятора может показать это как:
- текстовый отчёт от ИИ;
- список «узких мест» и проблемных связей/узлов (с фильтрацией и ссылками на первичные данные).

---

### 7.6. Авто‑генерация стресс‑сценариев

**Цель:** давать пользователю «набор кнопок» для быстрой проверки устойчивости сети под типовыми шоками, без ручного моделирования.

#### 7.6.1. Типовая таксономия стресс‑сценариев

ИИ может работать с набором паттернов:

- **Liquidity shock / отток ликвидности**:
  - часть участников резко снижает лимиты;
  - повышенная склонность к накопительству.

- **Panic episode / эпизод паники**:
  - резкое падение доверия в одном кластере;
  - массовое закрытие trustlines.

- **Hub failure / отказ хаба**:
  - выключение / «suspended» 1–2 центральных узлов;
  - перераспределение маршрутов.

- **Credit crunch / кредитное сжатие**:
  - общее снижение доступных лимитов по сети;
  - рост отказов по «нет маршрута/недостаток лимита».

#### 7.6.2. API

`POST /ai/generate-stress-scenarios`:

```json
{
  "baseScenario": { "...": "..." },
  "preferences": {
    "maxScenarios": 3,
    "focus": "trust_network_stability"
  }
}
```

Ответ:

```json
{
  "scenarios": [
    {
      "id": "stress_liquidity_shock_cluster_B",
      "label": "Отток ликвидности в кластере B",
      "description": "Резкое снижение лимитов и рост накопительства в районе B.",
      "patch": {
        "events": [
          {
            "time": "day_15",
            "type": "stress",
            "description": "Liquidity shock in cluster B",
            "effects": [
              {
                "targetGroup": "B",
                "applyBehaviorProfile": "hoarder",
                "scaleTrustlinesBy": 0.6
              }
            ]
          }
        ]
      }
    },
    {
      "id": "stress_hub_failure_h1",
      "label": "Отказ крупнейшего хаба h1",
      "description": "Выключение хаба h1 на 5 дней.",
      "patch": {
        "events": [
          {
            "time": "day_10",
            "type": "stress",
            "description": "Hub h1 suspended",
            "effects": [
              { "targetParticipantId": "h1", "setStatus": "suspended" }
            ]
          },
          {
            "time": "day_15",
            "type": "recovery",
            "description": "Hub h1 back online",
            "effects": [
              { "targetParticipantId": "h1", "setStatus": "active" }
            ]
          }
        ]
      }
    }
  ]
}
```

#### 7.6.3. Интеграция

- Клиент показывает список предложенных стресс‑сценариев (label/description).
- Для каждого сценария доступны действия: «показать патч», «запустить стресс‑тест».
- Симулятор запускает прогон, в котором патч применяется в указанное время/тик.

---

### 7.7. Рекомендации по антикризисным действиям

**Цель:** позволить ИИ не только диагностировать проблемы и генерировать стресс‑сценарии, но и **предлагать конкретные планы действий** (патчи) для выхода из кризисных ситуаций на уровне сообщества или отдельных кластеров.

#### 7.7.1. API

`POST /ai/recommend-crisis-actions`:

```json
{
  "snapshot": {
    "nodes": [...],
    "links": [...],
    "metrics": {
      "successRate": 0.62,
      "avgRouteLength": 4.1,
      "totalDebt": 180000,
      "clearingVolume": 30000,
      "bottlenecks": [
        { "participantId": "h1", "reason": "high_centrality_and_debt" },
        { "participantId": "cluster_B", "reason": "liquidity_shortage" }
      ]
    }
  },
  "goals": {
    "targetSuccessRate": 0.8,
    "maxAvgRouteLength": 3.0,
    "timeHorizonDays": 10
  },
  "constraints": {
    "maxChangedParticipants": 50,
    "maxTrustlineChangeFactor": 0.5,
    "allowSuspendHubs": true
  }
}
```

- `snapshot` — текущее состояние сети и ключевые метрики (как в 7.5), плюс, при необходимости, информация о уже активных стресс‑сценариях.
- `goals` — желаемые целевые значения метрик и горизонт времени (например, за 10 «дней» симуляции).
- `constraints` — операционные ограничения:
  - сколько участников допустимо затронуть;
  - насколько сильно можно менять лимиты (scale‑фактор);
  - можно ли временно выключать хабы и т.п.

**Ответ:**

```json
{
  "actionPlans": [
    {
      "id": "plan_diversify_h1",
      "label": "Разгрузка хаба h1 и диверсификация маршрутов",
      "description": "Снижение зависимости сети от единственного крупного хаба h1 за счёт расширения альтернативных маршрутов и поддержки периферийных узлов.",
      "patch": {
        "trustlines": [
          {
            "filter": { "to": "h1", "fromGroupNot": "center" },
            "scaleLimitBy": 0.7
          },
          {
            "filter": { "inCluster": true, "excludeHubs": true },
            "scaleLimitBy": 1.3
          }
        ],
        "behaviorProfiles": [
          {
            "id": "local_connector",
            "props": { "localismBias": 0.8, "trustPropensity": 0.6 },
            "rules": [
              {
                "trigger": "each_day",
                "action": "open_additional_intra_cluster_trustlines",
                "params": { "maxNewLinesPerDay": 2 }
              }
            ]
          }
        ],
        "participants": [
          {
            "filter": { "clusterId": "B", "type": "business" },
            "set": { "behaviorProfileId": "local_connector" }
          }
        ]
      },
      "expectedImpact": {
        "successRate": { "delta": 0.12 },
        "avgRouteLength": { "delta": -0.4 },
        "concentrationIndex": { "delta": -0.25 }
      },
      "rationale": [
        "Снизим нагрузку на h1, уменьшая лимиты на его входящих trustlines.",
        "Укрепим связи внутри кластеров, чтобы платежи реже шли через центральный хаб.",
        "Назначим части организаций поведение 'локальных коннекторов', стимулирующее альтернативные маршруты."
      ],
      "simulationPreviewId": "sim_preview_123"
    }
  ]
}
```

- `actionPlans[]` — 2–5 альтернативных планов:
  - `patch` — в том же DSL, что и обычные патчи (см. 7.4);
  - `expectedImpact` — прогноз по ключевым метрикам (дельты);
  - `rationale` — объяснение предлагаемой стратегии;
  - `simulationPreviewId` — ID быстрого «what‑if» сценария (если был выполнен дополнительный прогон).

#### 7.7.2. Алгоритм работы ИИ

Внутри `AI Scenario & Behavior Engine`:

1. Анализируется `snapshot`:
   - метрики, узкие места, накопление долгов;
   - активные стресс‑сценарии (если есть).
2. Определяется тип кризиса:
   - перегрузка одного/нескольких хабов;
   - нехватка ликвидности в определённых кластерах;
   - чрезмерная концентрация долгов;
   - массовые отказы по «нет маршрута/недостаток лимита»;
   - панические поведения определённых групп.
3. Формируются шаблоны возможных интервенций:
   - структурные: перераспределение лимитов, добавление альтернативных trustlines;
   - поведенческие: смена профилей поведения (ограничение over‑trust, увеличение localismBias, усиление clearing‑поведенческих правил);
   - процедурные: более частый клиринг, мягкое снижение активности risk‑агентов.
4. Из этих шаблонов строятся конкретные `actionPlans` с учётом `constraints`.
5. (Опционально) по каждому плану запускается короткая дополнительная симуляция:
   - короткий горизонт (несколько «дней»/тик‑циклов);
   - оценка улучшения/ухудшения метрик;
   - результат попадает в `expectedImpact` и `simulationPreviewId`.

#### 7.7.3. Интеграция

- Клиент показывает список планов действий с ожидаемыми эффектами и объяснением.
- Важно: ИИ **никогда не применяет планы автоматически** — только предлагает, пользователь подтверждает.
- Поддерживаются два режима:
  - «what‑if» прогон (отдельный run с патчем);
  - применение патча к текущему сценарию/прогону (если это допустимо по модели выполнения).

---

### 7.8. Минимальный план внедрения ИИ

1. **Сформировать и задокументировать схему сценария** (как в 7.2):
   - `participants`, `trustlines`, `behaviorProfiles`, `groups`, `events`.

2. **Добавить в backend симулятора API для работы со сценариями:**
   - `POST /scenario` — загрузка полного сценария;
   - `POST /scenario/:id/patch` — применение патча;
   - `POST /run` — запуск симуляции по `scenarioId`.

3. **Реализовать простой AI‑сервис (первый шаг):**
   - только `POST /ai/scenario-from-text`;
   - LLM + валидация JSON по схеме;
   - логирование: текст запроса, сгенерированный сценарий, модель ИИ, seed.

4. **Добавить клиентский слой (UI или CLI) для работы с ИИ:**
  - ввод промпта;
  - применение `scenario`/`patch`;
  - показ `summary` и результатов прогонов.

5. **Расширить AI‑сервис:**
   - добавить `patch-from-text`;
   - добавить `explain-current-state`;
   - добавить `generate-stress-scenarios`;
   - добавить `recommend-crisis-actions` (предложения по антикризисным действиям).

6. **Расширить клиент:**
  - сценарии/патчи/объяснения/стресс‑сценарии/антикризисные планы;
  - безопасное применение патчей с явным подтверждением.

---

## Заключение

Данный документ описывает симулятор для сети GEO, сфокусированный на воспроизводимых сценариях, нагрузке и аналитике. UI/визуализация фиксируются в отдельных спецификациях.

**Минимальный жизнеспособный продукт (MVP):**

1. Загрузка сценария (JSON/DSL) + валидация
2. Runner: генерация операций (платежи/trustlines/clearing) по расписанию
3. Управление интенсивностью (0–100%)
4. Метрики + снапшоты + артефакты прогона (для сравнения)

Следующий шаг развития — слой ИИ‑интеграции (раздел 7), который позволит:
- задавать конфигурации мира и поведения естественным языком,
- автоматически генерировать и изменять сценарии (патчи),
- получать объяснения текущего состояния сети и узких мест,
- автоматически конструировать стресс‑сценарии для тестирования устойчивости протокола GEO,
- а также получать **конкретные планы антикризисных действий**, которые можно безопасно протестировать на симуляции и при необходимости частично перенести в реальные политики протокола.
