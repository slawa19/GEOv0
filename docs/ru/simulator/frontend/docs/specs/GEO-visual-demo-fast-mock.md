# GEO Simulator — быстрая демка для утверждения визуала (на фикстурах)

**Статус:** проектная спецификация / план реализации демо

Цель: собрать **быструю, воспроизводимую демку** (без поднятия backend, но на детерминированных seed-based fixtures реальных прототипов комьюнити), чтобы утвердить:
- палитру и семантику цветов,
- размеры узлов (net-balance/кластеры),
- читаемость связей (alpha/width/LOD),
- состояния (suspended/left/deleted),
- поведение при фокусе/выборе/событиях (tx/clearing).

Ключевое правило (как в Admin UI): **клиент не вычисляет семантику визуализации** — визуальные решения приходят готовыми как `viz_*` (см. источник правды: [docs/ru/simulator/frontend/docs/api.md](../api.md)).

Этот документ описывает подготовку и разработку **demo-fast-mock v2**.
- Код демки: `simulator-ui/v2/`
- Legacy прототип (не трогаем, только как историческая справка): `simulator-ui/v1/`

Визуальные референсы (узлы/эффекты/сцены):
- `docs/ru/simulator/frontend/screen-prototypes/screenshots.md` (PROMPT A–F)

---

## 0) Архитектура демо (чтобы не повторять ошибки)

Цель демо — утвердить визуал, поэтому архитектура обязана быть:
- **воспроизводимой** (одни и те же входные данные → один и тот же результат),
- **fixture-first** (без backend),
- **совместимой с реальным API** (те же структуры `snapshot` и `events`).

### 0.1 Слои (рекомендуемая схема)

1) **Фон**: звёздная пыль/туманность (можно `tsparticles`), отдельный слой.
2) **Базовый граф** (Canvas/WebGL): узлы + рёбра, LOD по зуму.
3) **FX overlay** (второй canvas поверх графа): искры Tx, клиринг по маршруту/циклу, вспышки/кольца. **Статус:** ✅ DONE (2026-01-22) — выделен отдельный overlay-canvas (пока реализована clearing flash; частицы/искры — следующим шагом).
4) **HUD (HTML)**: контролы демо, карточка узла, (опционально) FPS/счётчики.

Примечание из phase1 tech spec: glow/bloom допустим как «атмосфера», но **знак баланса кодируем цветом узла, не внешним свечением**.

### 0.2 Поток данных

- Источник снапшота/событий: `public/simulator-fixtures/...`.
- На входе выполняем валидацию структуры (минимум: `nodes`, `links`, корректные `source/target`).
- События применяются как «оверлеи»:
  - не пересобирать граф полностью на каждый шаг,
  - временные эффекты держать отдельно от базового снапшота,
  - для перерисовки использовать лёгкий `refresh()`.

### 0.3 Детерминизм и fail-fast (обязательное)

- В демо **запрещён** runtime-fallback на случайный граф при ошибке загрузки.
- Нельзя использовать `Math.random()` для решений, влияющих на утверждение визуала (цвет/размер/классы/анимационные тайминги).
- При ошибке fixtures показываем понятную ошибку (где файл/что не так), чтобы быстро чинить пайплайн.

### 0.4 Анти-паттерны (ошибки первой демки — не повторять)

1) Смешивать загрузку данных, рендер, физику, ввод и FX в одном большом компоненте.
2) Вычислять семантику визуализации на клиенте (debt-bins/квантили/классы/толщины/альфы).
3) Генерировать случайные данные при ошибках вместо явного падения.
4) Постоянно пересоздавать граф/симуляцию на каждый клик/событие вместо accessors + `refresh()`.

## 1) Что считаем «быстрой демкой»

Демка должна запускаться командой:
- `cd simulator-ui/v2`
- `npm install`
- `npm run dev`

И открываться в браузере (Vite порт): http://localhost:5176/

**Никаких Docker/Postgres/Qdrant.**

---

## 1.1 TODO перед началом разработки (v2) + критерии приемки

Ниже список задач, которые должны быть сделаны **до** начала активной разработки визуала/FX, чтобы демка оставалась воспроизводимой и backend-first.

1) **Данные: fixtures-first источник правды (только готовые fixtures комьюнити)**
   - Демо v2 использует **только готовые fixtures, сгенерированные из прототипов реальных комьюнити** (`greenfield` / `riverside`).
   - Запрещены “ручные/кастомные” участники, параметры или урезанные под демо наборы данных.
   - UI загружает snapshot/events только из `public/simulator-fixtures/...` (без backend).
   - Fail-fast при любой ошибке загрузки/валидации.
   - Приемка:
     - если удалить/сломать файл fixtures → UI показывает понятную ошибку с путём файла;
     - UI не генерирует случайный граф как fallback.
     - узлы/параметры в демке воспроизводимо совпадают с теми же fixtures-паками, которые использует Admin UI (см. 2.0–2.1).

   **Статус:** ✅ DONE (2026-01-22)

2) **Контракт: runtime-валидация snapshot/events**
   - Проверяем соответствие структуре SoT: [docs/ru/simulator/frontend/docs/api.md](../api.md).
   - Приемка:
     - любой `snapshot.json` и `events/*.json` из набора демо проходят валидатор;
     - dangling edges (source/target без node) приводят к ошибке.

   **Статус:** ✅ DONE (2026-01-22)

3) **Политика `viz_*` ключей: таблица маппинга + строгий режим**
   - Зафиксировать конкретные стили и поведение для unknown keys (см. раздел 2.4).
   - Приемка:
     - неизвестный `viz_color_key`/`viz_width_key`/`viz_alpha_key` → ошибка (в demo v2).

   **Статус:** ✅ DONE (2026-01-22)

4) **Test-mode (детерминизм для визуальных тестов)**
   - Ввести режим, который отключает частицы/мерцание/переходы и фиксирует параметры рендера.
   - Приемка:
     - два запуска в test-mode дают одинаковые скриншоты Scene A–E.

   **Статус:** ✅ DONE (2026-01-22)

5) **Сцены A–E: “рельсы” для e2e/visual tests**
   - Зафиксировать точные пути fixtures (см. раздел 3) и UI-контролы выбора.
   - Приемка:
     - можно выбрать любую сцену без ручного редактирования кода;
     - Scene D/E запускают плейлист событий и корректно снимают overlay.

   **Статус:** ✅ DONE (2026-01-22)

6) **Опция различных вариантов группировки/раскладки участников (Layout modes)**
   - В демо есть переключатель раскладки (без изменения fixtures) для сравнения разных «линз» на одно и то же комьюнити.
   - Обязательные варианты:
     - текущий (community clusters — hubs + clusters),
     - децентрализованный как в Admin UI по умолчанию (force-like; аналог `fcose`).
  - Дополнительные варианты (для исследования визуала) допускаются, если они детерминированны.

  Почему это интересно пользователю (и зачем вообще переключатель):
  - Требование по UX: это **игровой интерфейс “вселенная с планетами”**, поэтому даже “аналитические” режимы должны оставаться космическими (галактика/созвездия), а не выглядеть как сортировка по колонкам.
  - **Galaxy (Admin UI vibe)** даёт ощущение “естественной” топологии связей (центры влияния/мосты/периферия) и позволяет сравнить восприятие с Admin UI, но в более “игровой” оболочке.
  - **Community clusters** подчёркивает «комьюнити вокруг хабов» (локальные группы) — удобнее читать крупные скопления.
  - **Constellations: balance** показывает полярность балансов (должники/нейтральные/кредиторы) как органические созвездия (force + «якоря» групп), а не как строгие полосы.
  - **Constellations: type** отделяет роли участников (институции vs люди) через органические созвездия (force + «якоря») — полезно понимать, кто образует ядро связности.
  - **Constellations: status** показывает операционное состояние сети (active/suspended/left/deleted) как отдельные органические “созвездия” (force + «якоря»), чтобы “выпавшие” участники читались быстро.
   - Приемка:
     - переключение layout не требует перезагрузки страницы;
     - layout детерминирован (одни и те же fixtures + одинаковый viewport → одинаковая картинка);
     - в `VITE_TEST_MODE=1` layout стабилен и пригоден для скриншотных тестов.

   **Статус:** ✅ DONE (2026-01-22)

### 1.1.1 Параметры «просторности» раскладки (для будущей настройки)

В демо v2 раскладка (включая `Community clusters` и все `Constellations:*`) реализована как **force-directed** симуляция.
Чтобы в будущем быстро реагировать на фидбек вида «сделай размещение просторнее / меньше сжато / больше воздуха», фиксируем набор параметров, которые будут тюниться (без изменения fixtures):

- `groupStrength` — сила притяжения узлов к “якорю” своей группы.
  - Больше значение → группы плотнее и «компактнее».
  - Меньше значение → группы расползаются и смешиваются с общей топологией (больше «естественная» сеть по связям).

- `linkDistanceScaleSameGroup` — коэффициент целевой длины ребра для связей **внутри** одной группы.
  - Меньше значение → внутри-групповые связи короче → группа сжимается.
  - Больше значение → внутри-групповые связи длиннее → больше воздуха внутри группы.

- `linkDistanceScaleCrossGroup` — коэффициент целевой длины ребра для связей **между** группами.
  - Меньше значение → группы тянутся друг к другу и сильнее смешиваются.
  - Больше значение → межгрупповые связи длиннее → группы держат дистанцию.

Практическое правило для запроса «сделай просторнее»:
- сначала увеличить `linkDistanceScaleSameGroup` и/или `linkDistanceScaleCrossGroup`;
- если группы всё равно слишком плотные — уменьшить `groupStrength`.

Примечание: эти параметры пока не вынесены в UI/env как публичные настройки; они зафиксированы здесь как словарь терминов для следующих итераций.

---

## 2) Источник данных (только фикстуры)

### 2.0 Откуда берутся фикстуры (контекст для будущих правок)

В проекте уже есть полный детерминированный пайплайн:

1) **Seed-документы (человекочитаемая спецификация сообщества)**
  - `docs/ru/seeds/*`
  - гайд/воркфлоу: `docs/ru/seeds/README.md`

2) **Детерминированная генерация канонических датасетов (реальные прототипы комьюнити)**
  - единая точка входа: `admin-fixtures/tools/generate_fixtures.py`
  - конкретные seed-скрипты (используются внутренне):
    - `admin-fixtures/tools/generate_seed_greenfield_village_100.py`
    - `admin-fixtures/tools/generate_seed_riverside_town_50.py`

  Команды (из корня репо):
  - `.\.venv\Scripts\python.exe admin-fixtures/tools/generate_fixtures.py --seed greenfield-village-100`
  - `.\.venv\Scripts\python.exe admin-fixtures/tools/generate_fixtures.py --seed riverside-town-50`

  Результат: перезапись канонического набора `admin-fixtures/v1/datasets/*.json`.

  Важно для демо v2: **участники и их параметры** (display_name/type/status/net_balance/viz_*) должны приходить именно из этого пайплайна. В демо **нельзя** подменять их “быстрыми” вручную подготовленными JSON.

  Примечание: есть режим “pack”, чтобы не ломать канон случайно:
  - `.\.venv\Scripts\python.exe admin-fixtures/tools/generate_fixtures.py --seed greenfield-village-100 --pack`
  - `.\.venv\Scripts\python.exe admin-fixtures/tools/generate_fixtures.py --seed greenfield-village-100 --pack --activate`

3) **Предвычисленные `participants.viz-<EQ>.json` (эмуляция backend-viz для моков)**
  - генератор: `admin-fixtures/tools/generate_participants_viz_datasets.py`
  - читает: `participants.json`, `equivalents.json`, опционально `debts.json`
  - пишет: `admin-fixtures/v1/datasets/participants.viz-<EQ>.json`

  Команда:
  - `.\.venv\Scripts\python.exe admin-fixtures/tools/generate_participants_viz_datasets.py --v1 admin-fixtures/v1`

4) **Синхронизация в Admin UI + валидация (чтобы сравнивать демо с real mode)**
  - sync: `admin-ui/scripts/sync-fixtures.mjs`
  - validate: `admin-ui/scripts/validate-fixtures.mjs`

  Команды:
  - `cd admin-ui`
  - `npm run sync:fixtures`
  - `npm run validate:fixtures`

  Требование для демо v2: при любых изменениях канонических fixtures демо должно оставаться сравнимым с Admin UI:
  - либо демо читает те же синхронизированные файлы, что и Admin UI fixtures-mode: `admin-ui/public/admin-fixtures/v1/datasets/*.json`,
  - либо демо держит собственную копию snapshot/events, **но она должна быть воспроизводимо сгенерирована из этих datasets** (и обновляться тем же пайплайном).

Guardrail: `validate-fixtures` держит allow-list `seed_id` (и ожидаемые размеры) — при добавлении нового seed нужно обновлять этот allow-list.

Отдельно: существует генератор “синтетики” для UI-прототипирования (не seed-based):
- `admin-fixtures/tools/generate_admin_fixtures.py` (по умолчанию пишет в `admin-fixtures/v1-synthetic`, в канон писать не рекомендуется)

### 2.1 Источник правды по данным
Используем существующие «канонические» датасеты:
- `admin-fixtures/v1/datasets/participants.viz-<EQ>.json` (узлы уже с `viz_*`)
- `admin-fixtures/v1/datasets/trustlines.json` (рёбра: `from→to`, `limit/used/available/status`)

Плюс опционально (если нужно для демо-лейблов/инфо в карточке):
- `admin-fixtures/v1/datasets/participants.json`
- `admin-fixtures/v1/datasets/debts.json`

**Важно:** направление trustline: `from → to` = creditor → debtor (risk limit), не наоборот.

### 2.2 Что именно кладём в демо
Демо потребляет **готовые snapshot JSON**, соответствующие контракту [docs/ru/simulator/frontend/docs/api.md](../api.md):
- `GraphSnapshot` (nodes/links, `viz_*` ключи)
- события (плейлист) для `tx.updated` / `clearing.plan` / `clearing.done`

То есть в рантайме UI **не собирает граф из сырых датасетов**.

Однако сами demo snapshot/events должны быть **произведены** (офлайн, детерминированно) из канонических seed-based fixtures комьюнити.
Это нужно, чтобы:
- демо оставалось репрезентативным (реальные участники/параметры),
- можно было сравнивать поведение визуала с Admin UI real mode на тех же данных.

---

### 2.3 Backend-first в рамках fixture-first демо

Терминологически это демо “без backend”, но подход остаётся **backend-first**:
- контракт данных (snapshot/events) считается “серверным” и стабильным;
- любые визуальные решения (цвет/размер/альфа/ширина) приходят как `viz_*` ключи;
- UI — только интерпретатор ключей + проигрыватель сценариев событий.

### 2.4 Политика неизвестных `viz_*` ключей (строгая для demo-fast-mock v2)

В demo-fast-mock v2 действует строгая политика:
- если встречен неизвестный `viz_color_key`/`viz_width_key`/`viz_alpha_key` → **ошибка и остановка сцены**;
- ошибка должна включать: тип ключа, значение, node/link id, и путь fixtures-файла.

Причина: демо предназначено для утверждения визуала, поэтому “тихий” fallback недопустим.

Опционально (на будущее, не обязательное для v2): можно иметь dev-флаг `ALLOW_UNKNOWN_VIZ_KEYS=1`, который переводит поведение в `warn + fallback`, но это **не дефолт**.

---

## 3) Файловая структура демо-фикстур

Структура demo fixtures для v2 (обслуживается Vite как static assets):

 - `simulator-ui/v2/public/simulator-fixtures/v1/`
  - `<EQ>/snapshot.json` (пример: `UAH/snapshot.json`)
  - `<EQ>/events/`
    - `demo-tx.json` (массив событий или JSONL)
    - `demo-clearing.json`
    - `demo-mixed.json`

Где `<EQ>`: в demo-fast-mock v2 используется **только** `UAH`.
Остальные эквиваленты подключаются только в **real mode** (будущий этап).

### 3.1 Точный список путей fixtures для сцен A–E (v2)

Базовый snapshot (по умолчанию для демо):
- `simulator-ui/v2/public/simulator-fixtures/v1/UAH/snapshot.json`

Требование: этот snapshot **не редактируется вручную** — он должен быть сгенерирован из канонических fixtures выбранного seed-комьюнити (greenfield/riverside) и оставаться сопоставимым с `admin-ui/public/admin-fixtures/v1/datasets/*`.

Плейлисты событий:
- Scene D (Tx burst): `simulator-ui/v2/public/simulator-fixtures/v1/UAH/events/demo-tx.json`
- Scene E (Clearing plan): `simulator-ui/v2/public/simulator-fixtures/v1/UAH/events/demo-clearing.json`

Семантика сцен:
- Scene A (Overview): использует только snapshot.
- Scene B (Focus): использует snapshot + пользовательский выбор узла (без событий).
- Scene C (Statuses): использует snapshot (в нём обязаны присутствовать узлы со статусами `suspended/left/deleted`).
- Scene D/E: snapshot + соответствующий events playlist.

---

## 4) Генерация демо-snapshot (офлайн, детерминированно)

### 4.1 Зачем генератор
Чтобы демо было:
- одинаковым у всех,
- без «вычислений на фронте»,
- устойчивым к изменению UI.

### 4.2 Генератор (реализовано)
Скрипт (офлайн):
- `admin-fixtures/tools/generate_simulator_demo_snapshots.py`

Вход (как источник правды):
- `admin-ui/public/admin-fixtures/v1/datasets/participants.viz-<EQ>.json`
- `admin-ui/public/admin-fixtures/v1/datasets/trustlines.json`
- (опционально, для событий) `admin-ui/public/admin-fixtures/v1/datasets/transactions.json`, `clearing-cycles.json`

Выход (fixtures для демо v2):
- `simulator-ui/v2/public/simulator-fixtures/v1/<EQ>/snapshot.json`
- `simulator-ui/v2/public/simulator-fixtures/v1/<EQ>/events/*.json`

### 4.3 Правила сборки snapshot
- `nodes`:
  - берём только участников, которые встречаются в trustlines выбранного эквивалента (или top-N по degree).
  - переносим `viz_color_key`, `viz_size`, `net_balance_atoms`, `net_sign` как есть.
- `links`:
  - `source = from`, `target = to`.
  - `trust_limit/used/available/status` копируем.
  - `viz_width_key` и `viz_alpha_key` **вычисляет генератор** (не UI), например:
    - `viz_width_key`: `hairline|thin|mid|thick` по квантилям `limit` или `used`.
    - `viz_alpha_key`: `bg|muted|active|hi` по `status` и/или `used/limit`.

---

## 5) Сценарии демо (минимальный набор для утверждения визуала)

Нужны 4–6 «сцен» (как презентационные пресеты), переключаемые из UI.

Связанные screen-prototypes (референсы к ожидаемому виду):
- `docs/ru/simulator/frontend/screen-prototypes/screenshots.md` (PROMPT A–F)

---

## 6.3 Таблица маппинга `viz_*` ключей → конкретные стили (v2)

Важно:
- это не “палитра по формуле”, а фиксированная таблица;
- UI применяет значения **как есть**;
- при unknown key действует строгая политика (см. 2.4).

Ниже канонический JSON (можно хранить как константу в UI и/или дублировать в snapshot.palette):

```json
{
  "node": {
    "color": {
      "business": { "fill": "#10b981" },
      "person": { "fill": "#3b82f6" },
      "suspended": { "fill": "#94a3b8" },
      "left": { "fill": "#64748b" },
      "deleted": { "fill": "#475569" },

      "debt-0": { "fill": "#84cc16" },
      "debt-1": { "fill": "#a3e635" },
      "debt-2": { "fill": "#d9f99d" },
      "debt-3": { "fill": "#f59e0b" },
      "debt-4": { "fill": "#f97316" },
      "debt-5": { "fill": "#fb7185" },
      "debt-6": { "fill": "#ef4444" },
      "debt-7": { "fill": "#dc2626" },
      "debt-8": { "fill": "#991b1b" }
    }
  },
  "link": {
    "width_px": {
      "hairline": 0.6,
      "thin": 1.0,
      "mid": 1.8,
      "thick": 2.6,
      "highlight": 2.4
    },
    "alpha": {
      "bg": 0.10,
      "muted": 0.22,
      "active": 0.45,
      "hi": 0.85
    },
    "color": {
      "default": "#64748b"
    }
  },
  "fx": {
    "tx_spark": {
      "core": "#ffffff",
      "trail": "#22d3ee"
    },
    "clearing_credit": "#22d3ee",
    "clearing_debt": "#f97316",
    "flash": {
      "clearing": { "from": "rgba(34,211,238,0.70)", "to": "rgba(34,211,238,0.00)" }
    }
  }
}
```

Привязка к прототипам:
- цвета/логика “спокойного” idle, focus, tx, clearing берутся из `screen-prototypes/screenshots.md`.

---

## 6.4 Test-mode (детерминизм для e2e/visual)

В `test-mode` UI должен:
- отключить частицы/искры/flash анимации или зафиксировать их в статическом кадре;
- отключить “дыхание/мерцание”;
- зафиксировать DPR clamp (например 1.0) и viewport в e2e;
- по возможности стабилизировать раскладку (seeded force / фиксация позиций после прогрева).

Рекомендованный флаг: `VITE_TEST_MODE=1`.

### Scene A — Overview (читаемость)
- Эквивалент: `UAH`
- Цель: в зуме «общая карта» видно кластеры и основные долги.
- Проверяем: фоновые линии не шумят, debtor bins читаются.

### Scene B — Focus (карточка + локальные связи)
- Выбор узла + подсветка соседей.
- Проверяем: типографика карточки и контраст текста/фона.

### Scene C — Statuses
- В snapshot должны быть узлы со статусами `suspended/left/deleted`.
- Проверяем: паттерны/оттенки не путаются с debtor-цветами.

### Scene D — Tx burst (события)
- Плейлист событий `tx.updated` (10–30 событий за 10–20 секунд).
- В плейлисте обязательно должны быть:
  - 2–3 одиночных tx по одному ребру,
  - 1–2 tx по маршруту из нескольких рёбер (multi-hop), чтобы визуальная метафора не «запирала» нас в A→B.
- Проверяем: частицы/подсветка не убивают FPS; событие читается.

### Scene E — Clearing plan
- Один сценарий `clearing.plan` на 3–8 шагов + `clearing.done`.
- Желательно: хотя бы один цикл длиной 4–6 узлов (не только треугольник), чтобы проверить читаемость на «реальном» масштабе.
- Проверяем: ритм и считываемость, overlay снимается корректно.

---

## 6) Требования к UI демо (минимум, но “как продукт”)

### 6.1 Панель демо-контролов
- Выбор `Equivalent` (селект)
- Выбор `Scene` (селект)
- Кнопки:
  - `Play/Pause` (плейлист событий)
  - `Step` (следующее событие)
  - `Reset view` (вернуть дефолтный зум/пан)
- Переключатели:
  - `Labels: off / selection / neighbors` (LOD)
  - `Quality: low/med/high` (dprClamp)

### 6.2 Типографика и текстовые роли
Для всего текста в демо (панель/карточки/подсказки) использовать принципы:
- [docs/ru/admin-ui/typography.md](../../../../admin-ui/typography.md)

(Да, демо не на Element Plus, но роли/масштаб/иерархия должны совпадать.)

---

## 7) Критерии «визуал утверждён» (Definition of Done)

- На `Scene A` в 1–2 уровнях зума:
  - кластеры визуально различимы,
  - линии не превращаются в «шерсть»,
  - debtor bins считываются (не сливаются в один цвет).
- На `Scene C` статусные состояния не путаются с debtor-градиентом.
- На `Scene D/E`:
  - UI держит стабильный рендер без заметных провалов (визуально),
  - overlay/частицы ограничены по количеству,
  - после `clearing.done` эффекты снимаются и сеть возвращается к «базе».

---

## 8) Негативные требования (что НЕ делаем в демке)

- Не подключаем реальный backend.
- Не делаем авторизацию.
- Не делаем реальные расчёты маршрутов/клиринга.
- Не строим сложную аналитику.

---

## 9) Мини-план внедрения (чтобы сделать за 0.5–1 день)

1) Сгенерировать `snapshot.json` для `UAH` из существующих датасетов (офлайн скриптом).
2) Положить snapshot в `simulator-ui/v2/public/simulator-fixtures/v1/UAH/snapshot.json`.
3) Добавить в `simulator-ui` режим `VITE_DEMO_FIXTURES=1`, который грузит snapshot локально.
4) Добавить 2 плейлиста событий: `demo-tx`, `demo-clearing`.
5) Сделать панель выбора `Scene` (эквивалент в демо фиксирован: `UAH`).

---

## 10) Примечания по совместимости с текущим кодом `simulator-ui`

Сейчас `simulator-ui` пытается грузить `${VITE_API_BASE_URL}/graph/snapshot` и при ошибке падает в генератор случайного графа.

В демо-режиме предлагается:
- не использовать сетевой API,
- грузить static snapshot из `public/simulator-fixtures/...`.

Это позволит утвердить визуал на «настоящих» (пусть и фикстурных) данных и без нестабильности от рандома.

---

## 11) Подход к тестированию (исчерпывающее покрытие)

Цель тестов в демо — не «доказать математику сети», а гарантировать:
- **детерминизм** (одни и те же fixtures → одинаковый результат),
- **fail-fast** по данным (ошибки видны сразу и понятно),
- **регресс-устойчивость** визуала (сцены не “плывут” от правок UI),
- **паритет** fixtures/API (контракт snapshot/events соблюдается).

Рекомендуемая пирамида тестов:
1) Unit: чистая логика (валидатор, плеер событий, LOD/режимы).
2) Integration: рендер-адаптер + store + эффекты (без «настоящих» сетевых запросов).
3) E2E + Visual: гарантируем UX и ключевые сцены (A–E) + smoke по F.

### 11.1 Инструменты (предложение)

- Unit/Integration: `vitest` + `@vitest/browser` (опционально) + `happy-dom`.
- E2E/visual: `playwright` (скриншоты по сценам).
- Валидация данных: `zod` (runtime) + отдельные тесты на fixtures.

Примечание: важнее принцип, чем конкретная библиотека — но **runtime-валидация + автотесты на fixtures обязательны**.

### 11.2 Unit-тесты (чистая логика)

1) **Schema validation (snapshot/events)**
   - Валидируем `GraphSnapshot`, `GraphNode`, `GraphLink` по SoT: `docs/ru/simulator/frontend/docs/api.md`.
   - Отдельный тест: все demo fixtures в `public/simulator-fixtures/...` проходят валидацию.
   - Негативные кейсы:
     - отсутствует `nodes/links`,
     - link указывает на несуществующий node,
     - `viz_*` ключи неизвестны (должно быть предупреждение/ошибка в dev режиме — policy фиксируется).

2) **Determinism guardrails**
   - Тест “нет runtime-random fallback”: при ошибке загрузки fixtures → показываем ошибку, не генерируем случайный граф.
   - Если используется PRNG для “дыхания/мерцания” — он seeded и не влияет на смысл (тестом фиксируем набор параметров).

3) **Scene state machine**
   - Переключение `Equivalent`/`Scene`:
     - корректно сбрасывает overlays,
     - корректно сбрасывает выбранный узел,
     - не вызывает перезагрузку страницы,
     - не пересоздаёт симуляцию без необходимости (policy фиксируем).

4) **Event playlist player**
   - `Play/Pause/Step/Reset`:
     - `Step` применяет ровно 1 событие,
     - `Pause` не применяет события,
     - `Reset` возвращает “чистое” состояние без хвостов.
   - Тайминги:
     - `ttl_ms` корректно снимает эффекты,
     - `clearing.plan.steps[].at_ms` исполняются по расписанию.

5) **LOD / Labels policy**
   - По умолчанию labels выключены.
   - В режиме `selection` подпись только выбранного.
   - В режиме `neighbors` — выбранный + соседи (без глобальных подписей).

### 11.3 Integration-тесты (сборка модулей)

Цель: проверить, что связка loader → store → renderer → overlays работает как ожидается.

Минимальный набор:
- Загрузка локального snapshot → graph отображён (smoke: нет ошибок и есть хотя бы N узлов в модели рендера).
- Выбор узла:
  - переход в `Focus` (или эквивалентный режим),
  - подсвечиваются incident links,
  - карточка узла отображается с корректными текстовыми ролями (см. `docs/ru/admin-ui/typography.md`).
- Применение `tx.updated`:
  - активируется overlay на нужных рёбрах/узлах,
  - overlay снимается после `ttl_ms`.
- Применение `clearing.plan` + `clearing.done`:
  - эффекты запускаются шагами,
  - в конце все эффекты сняты.

Примечание по производительности: integration-тесты не обязаны мерить FPS, но должны проверять, что UI **не пересобирает graphData** на каждый шаг события (если архитектурно заявлено использование `refresh()`/accessors).

### 11.4 E2E + Visual regression (обязательная “страховка”)

E2E сценарии (Playwright):
1) **Scene A (Overview)**: страница загрузилась без ошибок, сеть видна, HUD виден.
2) **Scene B (Focus)**: клик по узлу → появляется карточка, подсветка связей, кнопки доступны.
3) **Scene D (Tx burst)**:
   - `Play` запускает события,
   - есть видимый индикатор активности (например счетчик/статус),
   - `Pause` останавливает,
   - `Reset view` возвращает камеру.
4) **Scene E (Clearing)**: `Run Clearing` запускает план, в конце UI возвращается в base.

Visual regression (скриншоты):
- Фиксируем по одному golden screenshot на Scene A–E (F — опционально),
- одинаковый viewport (например 1440×900) + фиксированный DPR,
- отключаем “не-детерминизм” (анимации/мерцания) специальным test-mode флагом.

### 11.5 Контрактные тесты на fixtures (важно для “fixture-first”)

Отдельный тест/скрипт должен:
- пройти по всем файлам `public/simulator-fixtures/**/snapshot.json` и `events/*.json`,
- провалиться с понятной ошибкой (путь + причина), если:
  - нарушена структура,
  - встречены неизвестные `viz_*_key`,
  - есть dangling edges.

Это защищает демо от “тихого” разъезда данных и ускоряет работу с генераторами.

### 11.6 Performance smoke (необязательный, но полезный)

Если хочется автоматизировать “не стало хуже”:
- тест “крупный snapshot” (например 150 nodes / 300 links) должен отрисоваться < X секунд до первого кадра,
- опционально логировать rough metrics (кол-во узлов/рёбер/particles).

Важно: эти тесты не должны быть flaky — лучше ограничиться стабильными метриками (TTFR/TTI) и внятными лимитами.
