# Архитектура MVP GEO для локального сообщества

**Вариант B, ревизия v0.1: community‑hub + лёгкие клиенты + протокол GEO v0.1**

Документ описывает архитектуру минимально жизнеспособного продукта (MVP) системы GEO для **одного локального сообщества** с возможностью эволюции:

- к **кластеру узлов** внутри сообщества;
- к **взаиморасчётам между несколькими сообществами** (cluster‑to‑cluster);
- к частичному **p2p‑режиму** между «толстыми» клиентами.

Архитектура согласована с **протоколом GEO v0.1**: trustlines, долги, платежи и клиринг реализуются в виде формальных транзакций и стейт‑машин, а community‑hub играет роль координатора в MVP.

------

## 1. Цели и рамки MVP

### 1.1. Цели

- Реализовать **экономику взаимного кредита** внутри одного локального сообщества (10–500 участников):
  - линии доверия (TrustLines) между участниками;
  - рёбра долгов (Debts/Obligations);
  - операции `PAYMENT` по сети доверия;
  - автоматический поиск и запуск простых циклов клиринга (`CLEARING`) длиной 3–4.
- Обеспечить **приемлемый UX**, пригодный для не‑технического сообщества:
  - web‑клиент (desktop/mobile browser, PWA);
  - по возможности — лёгкая адаптация в мобильное приложение.
- Сохранить **структурную открытость**:
  - в будущем — мульти‑хабовая конфигурация (несколько сообществ, связанных trustlines между хабами);
  - частичная децентрализация (собственные ноды крупных участников, p2p‑коммуникации);
  - потенциальная интеграция с блокчейнами и платёжными шлюзами.

### 1.2. Ограничения и допущения MVP

- **Один** community‑hub на сообщество.
- Нет глобального блокчейна/ledger; есть:
  - локальная БД hub’а как источник истины для сообщества;
  - криптографические подписи участников на критических операциях (trustlines, клиринг, постепенно — платежи).
- Используем простой, проверенный протокол:
  - маршрутизация — BFS с лёгким multi‑path;
  - консистентность по пути — двухфазный коммит (2PC);
  - поиск циклов для клиринга — локально‑триггерный на малые длины (3–4).
- Межсообществовый обмен:
  - **протокольно** описан (хабы как обычные участники),
  - может быть реализован позже, без изменения базовых сущностей.

------

### 2. Общий архитектурный обзор

#### 2.1. Высокоуровневая схема

```
text+-----------------------------+
|        Пользователи        |
|  - Клиентское приложение   |
|    (моб./десктоп)          |
|  - Web-интерфейс (админка) |
+--------------+--------------+
               |
               | HTTPS / WebSocket (JSON, протокольные сообщения)
               v
+-----------------------------+
|      API / Gateway-слой     |
|  (часть backend-ядра)       |
+--------------+--------------+
               |
               v
+-----------------------------+
|     Community Hub Core      |
|                             |
|  - Auth & Identity          |
|  - TrustLines Service       |
|  - RoutingService           |
|  - PaymentEngine (2PC)      |
|  - ClearingEngine (циклы)   |
|  - Reporting & Analytics    |
|  - Система аддонов          |
+--------------+--------------+
               |
               v
+-----------------------------+
|          Data Layer         |
|  - Реляционная БД (ACID)    |
|  - Кэш/очереди              |
+-----------------------------+

+-----------------------------+
|   Crypto / Key Management   |
|  - Ключи на клиенте         |
|  - Подписание операций      |
+-----------------------------+
```

#### 2.2. Роль hub’а

Hub:

- координирует транзакции `PAYMENT` и `CLEARING`;
- хранит и индексирует состояние сети доверия и долгов внутри сообщества;
- предоставляет унифицированное API (HTTP/WebSocket) для клиентов и аддонов;
- выступает в роли участника (Participant) при межсообществовом обмене.

Архитектурно hub реализован как **ядро + система аддонов**:

- ядро отвечает за протокол GEO v0.1, базовые доменные сущности и гарантии целостности;
- аддоны/интеграции могут добавлять:
  - дополнительные отчёты и интерфейсы;
  - специфическую бизнес‑логику;
  - интеграции с внешними системами (например, мессенджеры, шлюзы и т.п.).

При этом:

- приватные ключи участников хранятся только на клиентских устройствах;
- hub не владеет средствами, а лишь фиксирует и координирует обязательства между участниками.

------

Ниже — переработанный и расширенный **раздел 3. Сущности и протокольная модель**, в старом формате, но с более подробной логикой и связями между объектами.

------

## 3. Сущности и протокольная модель

Раздел описывает **минимальный набор сущностей**, на которых строится протокол GEO v0.1 и архитектура MVP. Важно не только перечислить поля, но и понять:

- кто что «контролирует»;
- какие инварианты система обязана поддерживать;
- как эти сущности участвуют в платежах и клиринге.

### 3.1. Участник (Participant)

**Участник** — это любая сущность, которая может:

- давать и получать доверие;
- накапливать долги и кредиты;
- инициировать транзакции (trustlines, платежи, клиринг).

Это может быть:

- физлицо;
- организация;
- hub (узел сообщества, который тоже участвует в сети как Participant).

Основные поля:

- `PID`: устойчивый идентификатор участника, логически производный от публичного ключа (`Ed25519`). Пример возможной схемы:

  ```text
  PID = base58(sha256(public_key))
  ```

  Важно: PID — **чистая функция** от публичного ключа. Это позволяет другим участникам убедиться, что данный PID действительно принадлежит владельцу конкретного pubkey.

- `public_key`: публичный ключ Ed25519.

- Профиль:

  - «человеческое» имя или название организации;
  - тип участника (`person`, `organization`, `hub` и т.п.);
  - дополнительные метаданные (контакты, описание, ссылки и т.д.).

- Статус:

  - `active` — участник активен, может открывать trustlines и участвовать в платежах;
  - `suspended` — временно заморожен (по решению сообщества или самого участника);
  - `left` — формально вышел из сообщества, но его прошлые обязательства ещё могут учитываться;
  - `deleted` — логически удалён (используется осторожно, обычно при миграциях/ошибках).

**Инварианты и свойства:**

- Все действия, имеющие долговременные последствия (изменение trustlines, согласие на клиринг, критичные настройки), должны быть **подписаны** приватным ключом участника и проверены по его `public_key`.
- Участник может быть одновременно:
  - «узлом доверия» (держать trustlines с другими);
  - «хабом» (если у него есть дополнительные обязанности по координации).
- Участник всегда существует **в контексте какого-то сообщества** (локального хаба). В межсообществовом сценарии один и тот же PID может фигурировать в нескольких хабах, но каждая инстанция хранит свой локальный набор trustlines/долгов.

------

### 3.2. Эквивалент (Equivalent)

**Эквивалент** — это способ назвать и формализовать то, в чём измеряется долг.

Это может быть:

- денежная единица (например, `"UAH"`, `"USD"`);
- час времени (`"HOUR"`, `"HOUR_DEV"`);
- единица ресурса (`"kWh"`, `"KG_WHEAT"`).

Основные поля:

- `code`: строка, uniquely идентифицирующая эквивалент в рамках хаба (и, желательно, стабильная при обмене данными между хабами). Примеры:
  - `"UAH"`, `"EUR"`, `"HOUR_CARE"`, `"LOCAL_UNIT"`.
- `precision`: количество знаков после запятой, допустимое для операций с этим эквивалентом. Например:
  - фиат обычно 2 знака;
  - электроэнергия может быть 3–4;
  - часы работы — 2 знака вполне достаточно.
- `metadata`:
  - человекочитаемое описание;
  - тип эквивалента (фиат, время, ресурс, внутренняя условная единица сообщества);
  - возможная привязка к внешнему идентификатору (ISO‑код валюты, код товара и т.п.).

**Ключевые моменты:**

- В системе **нет «валюты по умолчанию»**. Любая операция всегда явно указывает эквивалент (E).
- Одни и те же участники могут иметь:
  - trustlines в разных эквивалентах;
  - долги в разных эквивалентах.
- Эквивалент не задаёт курс обмена. В MVP GEO не занимается автоматическим конвертированием между эквивалентами.

------

### 3.3. Линия доверия (TrustLine)

**TrustLine** — это соглашение вида: «участник A разрешает участнику B быть должен ему до определённого лимита в эквиваленте E».

Важно понимать:

- это **не сам долг**, а только потолок допустимого долга;
- это **одностороннее** выражение доверия: `A → B` не то же самое, что `B → A`.

Поля:

- `from` (PID) — участник, который даёт доверие (кредитор по лимиту).
- `to` (PID) — участник, который может стать должником в рамках этого доверия.
- `equivalent` (E) — эквивалент, в котором измеряются будущие долги.
- `limit` — максимальный объём долга, который `to` может иметь перед `from` в эквиваленте E.
- `policy` (JSON) — набор дополнительных правил и настроек, например:
  - флаг авто‑согласия на участие в клиринге: можно ли автоматически уменьшать долги в циклах без отдельного подтверждения;
  - разрешение/запрет быть посредником в маршрутах платежей (`can_be_intermediate = true/false`);
  - ограничение на суточный оборот (`daily_outgoing_limit`) и т.п.
- `status` — `active | frozen | closed`:
  - `active` — линия может использоваться;
  - `frozen` — временно не используется для новых операций (но долг может оставаться);
  - `closed` — линия закрыта; новые долги по ней не создаются, оставшиеся долги должны быть погашены или обнулены через клиринг.

**Базовый инвариант по лимиту:**

[ debt[to \to from, E] \le limit(from \to to, E) ]

То есть текущий долг `to` перед `from` в эквиваленте E **никогда** не должен превышать указанного лимита. Operation `PAYMENT`, которая нарушила бы этот инвариант, должна быть отклонена в фазе PREPARE.

**Свойства владения и изменений:**

- Линия доверия `A → B` принадлежит A. Только A вправе:
  - создать такую линию (`TRUST_LINE_CREATE`);
  - изменить её параметры (`TRUST_LINE_UPDATE`);
  - закрыть (`TRUST_LINE_CLOSE`).
- Все эти операции оформляются как транзакции `TRUST_LINE_*`, **подписанные приватным ключом `from`**.
- В более сложных сценариях (не обязательно в MVP) допускаются двухсторонние или мультисторонние соглашения, но фундамент остаётся тем же: каждая конкретная запись trustline контролируется её `from`.

------

### 3.4. Долг (Debt / Obligation)

**Debt** — это уже не намерение, а конкретное обязательство: «участник X должен участнику Y сумму S в эквиваленте E».

Поля:

- `debtor` (PID_X) — должник;
- `creditor` (PID_Y) — кредитор;
- `equivalent` (E);
- `amount` > 0 — текущая сумма долга.

Интерпретация:

- X должен Y `amount` в эквиваленте E. Это **фактическое состояние**, на которое можно опираться при расчёте балансов, клиринге, рисках и т.д.

**Агрегация и направление:**

- Для каждой тройки `(debtor, creditor, equivalent)` хранится **ровно одна агрегированная запись**.
- Если есть взаимные обязательства (X должен Y и Y должен X в одном и том же E), это может быть реализовано:
  - либо как две независимые записи (`X→Y` и `Y→X`),
  - либо как одна усреднённая запись (но в MVP проще и прозрачно вести две).
- Долг — строго направленная сущность: направление важно для следующего:
  - кем лимит потратился;
  - кто несёт риск;
  - как идут платежные маршруты.

**Связь с TrustLine:**

Если не предусмотрена политика «беслимитного долга», то действует ограничение:

[ debt[B \to A, E] \le limit(A \to B, E) ]

То есть долг B перед A не может превысить то, что A разрешил в своей линии доверия.

Это проверяется:

- при исполнении платежа (в PaymentEngine во время PREPARE);
- при изменении лимита trustline (в TrustLines Service), если работает логика «нельзя снизить лимит ниже уже существующего долга».

**Участие в платежах и клиринге:**

- Платёж `PAYMENT` вдоль маршрута повышает долги на определённых рёбрах (например, B начинает больше должен C и т.п.).
- Клиринг `CLEARING` снижает долги по рёбрам цикла, иногда обнуляя их.

Таким образом, таблица `debts` — это **главный динамический слой** системы, который меняется во времени, в то время как trustlines задают более стабильную «рамку» рисков и доверия.

------

### 3.5. Транзакция (Transaction) и состояния

**Transaction** — это единица изменений в системе. Любая значимая операция фиксируется как транзакция, имеет идентификатор, состояние, набор подписей и полезную нагрузку.

Общие поля:

- `tx_id`:
  - глобальный идентификатор (UUID или хеш содержимого транзакции);
  - должен быть уникальным в рамках хаба;
  - служит для идемпотентности (повторная обработка того же `tx_id` не должна менять состояние повторно).
- `type` — тип транзакции:
  - `TRUST_LINE_CREATE`
  - `TRUST_LINE_UPDATE`
  - `TRUST_LINE_CLOSE`
  - `PAYMENT`
  - `CLEARING`
- `initiator` (PID) — участник, инициировавший транзакцию (например, тот, кто отправил `PAYMENT_REQUEST`, или тот, кто изменяет trustline).
- `payload` (структурированный JSON):
  - содержит специфичные для транзакции данные: параметры trustline, маршруты платежа, описание цикла при клиринге и т.п.;
  - формат строго определён протоколом для каждого `type`.
- `signatures` (JSON: роль/участник → подпись):
  - один или несколько элементов вида `{ "participant": PID_A, "role": "from", "signature": "..." }`;
  - подписи позволяют привязать согласие конкретных участников к конкретной транзакции.
- `timestamp` — время создания/инициации транзакции (локальное или логически согласованное).
- `state` — **статус в стейт‑машине**, зависящий от `type`.

------

#### 3.5.1. Стейт‑машина для `PAYMENT`

Транзакция `PAYMENT` описывает попытку перевести «стоимость» от одного участника к другому через сеть доверия.

Состояния:

- `NEW`:
  - транзакция создана после получения `PAYMENT_REQUEST` от инициатора;
  - в payload есть базовые поля: от кого, кому, эквивалент, сумма, возможные ограничения.
- `ROUTED`:
  - RoutingService нашёл один или несколько маршрутов;
  - в `payload` добавляется `routes[]` — массив путей с разбивкой суммы по каждому;
  - эти маршруты ещё не применены, а только предложены к применению.
- `PREPARE_IN_PROGRESS`:
  - PaymentEngine запустил фазу PREPARE:
    - рассчитаны локальные эффекты по рёбрам (как изменятся долги);
    - выполняются проверки лимитов и политик;
    - временно резервируется ёмкость по trustlines/долгам для предотвращения гонок;
  - пока транзакция в этом состоянии, она «готовится», но итог ещё не известен.
- `COMMITTED`:
  - все проверки и резервирования завершились успешно;
  - изменения долгов были атомарно применены в БД;
  - резервы освобождены;
  - итоговое состояние отражено в таблице `debts`.
- `ABORTED`:
  - транзакция не может быть завершена:
    - не найден маршрут;
    - не хватает лимитов;
    - один из участников отказался;
    - произошёл таймаут или ошибка;
  - все временные резервы сняты;
  - долговое состояние вернулось к тому, что было до начала этой транзакции.

**Инвариант:**

- Переходы по состояниям должны следовать допустимым шагам:
  - `NEW → ROUTED → PREPARE_IN_PROGRESS → COMMITTED`
  - `NEW → ROUTED → PREPARE_IN_PROGRESS → ABORTED`
  - `NEW → ABORTED` (если вообще не удалось найти маршруты и т.п.)
- Повторные попытки выполнить `COMMIT` или `ABORT` по уже зафиксированному `tx_id` не должны менять состояние (`idempotent`).

------

#### 3.5.2. Стейт‑машина для `CLEARING`

Транзакция `CLEARING` описывает попытку уменьшить (частично или полностью) набор долгов, образующих цикл, без внешних денежных переводов.

Состояния:

- `NEW`:
  - ClearingEngine обнаружил циклическую структуру долгов по эквиваленту E;
  - рассчитана максимальная возможная сумма S для «схлопывания»;
  - создана транзакция с описанием цикла и суммы.
- `PROPOSED`:
  - (опциональное состояние, если нужен явный консенсус всех участников цикла);
  - участникам отправлены предложения участвовать в клиринге с указанием суммы S и структуры цикла.
- `WAITING_CONFIRMATIONS`:
  - система ожидает явных ответов от участников (ACCEPT/REJECT);
  - возможен таймаут, по истечении которого «молчание» трактуется по правилам (чаще всего как отказ).
- `COMMITTED`:
  - либо:
    - настроено авто‑согласие (по trustline‑политикам);
    - все условия выполнены, и можно сразу применять транзакцию;
  - либо:
    - все участники явно подтвердили участие;
  - в обоих случаях:
    - долги по рёбрам цикла уменьшаются на сумму S;
    - инварианты по лимитам и знакам сумм сохраняются;
    - изменения зафиксированы в БД.
- `REJECTED`:
  - хотя бы один участник отказался;
  - или наступил таймаут без нужного числа подтверждений;
  - состояние долгов **не меняется** (по сравнению с моментом создания транзакции).

**Упрощение для MVP:**

- В начальной реализации можно:
  - использовать только режим авто‑согласия (при условии, что это безопасно с точки зрения доверия);
  - обходиться без явных состояний `PROPOSED` и `WAITING_CONFIRMATIONS` — сразу переходить из `NEW` в:
    - `COMMITTED`, если все проверки и политики позволяют автоклиринг;
    - либо `REJECTED`, если обнаружено препятствие.

------

#### 3.5.3. Транзакции trustlines

Операции `TRUST_LINE_CREATE`, `TRUST_LINE_UPDATE`, `TRUST_LINE_CLOSE` в MVP могут использовать упрощённую модель состояний:

- `PENDING` — транзакция создана, подпись проверяется, бизнес‑правила валидируются;
- `COMMITTED` — изменения успешно применены к записи о trustline в БД;
- `FAILED` — операция отклонена:
  - неправильная подпись;
  - нарушение внутренних инвариантов (например, попытка снизить лимит ниже текущего долга);
  - бизнес‑ограничения сообщества.

Также допустимо в MVP сразу фиксировать такие транзакции как `COMMITTED/FAILED` без долгой жизни в состоянии `PENDING`, если проверка и применение займут пренебрежимо малое время.

------

## 4. Backend: сервисы и ответственность

### 4.1. Auth & Identity

- Регистрация:
  - принимает `public_key`, данные профиля;
  - формирует `participant` с `PID`;
  - связывает с учётной записью (email/телефон).
- Логин:
  - по email/телефону + пароль/OTP;
  - выдача JWT access/refresh токенов.
- Управление сессиями:
  - хранение blacklist/whitelist токенов (опционально в Redis).

### 4.2. TrustLines Service

Задачи:

- Обработка протокольных сообщений `TRUST_LINE_CREATE/UPDATE/CLOSE`:
  - проверка подписи `from`;
  - проверка бизнес‑политик (лимиты, суммирование, статусы участников);
  - изменение таблицы `trust_lines`;
  - запись соответствующей транзакции.
- Валидация при платежах:
  - предоставление информации о доступных лимитах для RoutingService и PaymentEngine.

### 4.3. RoutingService (поиск маршрутов)

Задачи:

- Для платежа `(A → B, E, S)`:

  - оценить `available_credit` по каждому ориентированному рёбру:

    [ available_credit(A \to B, E) = limit(A \to B, E) - debt[B \to A, E] ]

    (Если лимита нет — трактуем как 0 или по политике.)

  - найти 1–3 пути `P1, P2, ...` при помощи BFS (ограничение длины пути `max_hops`, например 4–5).

- Light multi‑path:

  - шаг 1: найти `P1`, посчитать `c1 = min(available_credit(e) по e∈P1)`;
  - если `c1 ≥ S` — использовать только `P1`;
  - если `c1 < S`:
    - «зарезервировать» `c1` на рёбрах `P1` (в расчётах);
    - попытаться найти `P2`, посчитать `c2`;
    - если `c1 + c2 ≥ S` — разбить платёж на два маршрута;
    - можно ограничиться двумя путями в MVP (третьего, как правило, достаточно редко требует практическая сеть).

Результат:

```json
"routes": [
  {
    "path": ["A", "X1", "B"],
    "amount": 40.0
  },
  {
    "path": ["A", "Y1", "Y2", "B"],
    "amount": 20.0
  }
]
```

### 4.4. PaymentEngine (исполнение платежей, 2PC)

Задачи:

1. **Создание транзакции `PAYMENT`**:

   - по `PAYMENT_REQUEST` от клиента:
     - создать запись в `transactions` (`type=PAYMENT`, `state=NEW`, `initiator=A`);
     - вызвать RoutingService → получить `routes[]`;
     - сохранить `routes` в `payload`;
     - изменить `state` на `ROUTED`.

2. **Фаза PREPARE**:

   - для каждого участника, затронутого маршрутами:

     - сформировать локальные эффекты:

       ```json
       {
         "debtor": "PID_X",
         "creditor": "PID_Y",
         "equivalent": "E",
         "delta": +amount
       }
       ```

     - проверить, что:

       - после применения `delta` не будет превышено `limit` по TrustLines;
       - не нарушаются локальные политики (например, запрещён конкретный посредник).

   - зарезервировать ресурсы:

     - реальные резервы — на уровне Redis (структуры `prepare_locks`);
     - либо через транзакции БД (но не держать их слишком долго).

   - если проверки по всем участникам и рёбрам успешны:

     - выставить `state = PREPARE_IN_PROGRESS`.

   - если хотя бы одно ребро/участник не проходит проверки:

     - отменить все резервы;
     - пометить транзакцию как `ABORTED`.

3. **Фаза COMMIT / ABORT**:

   - при успехе PREPARE:
     - в рамках транзакции БД:
       - обновить `debts` по всем рёбрам (увеличить долги);
       - удалить все резервы для `tx_id`;
       - пометить транзакцию `COMMITTED`.
   - при неуспехе:
     - снять резервы;
     - `state = ABORTED`.

В MVP hub может «эмулировать» сообщения `PAYMENT_PREPARE/COMMIT` локально, а не через сеть, но архитектура и протокол сообщений должны их предусматривать (для будущего p2p/межхабового режима).

### 4.5. ClearingEngine (поиск и исполнение клиринга)

Задачи:

1. **Локально‑триггерный поиск циклов**:

   - после `PAYMENT.COMMITTED`:

     - взять изменённые рёбра долгов;
     - построить малый подграф вокруг этих рёбер (радиус 2–3);
     - найти циклы длиной 3–4:
       - пример: `A → B → C → A` или `A→B→C→D→A`.

   - для каждого цикла:

     [ S = \min(debt[Vi \to V(i+1)]) ]

     если (S > \epsilon) (порог, например, 0.01), формировать кандидат `CLEARING`.

2. **Формирование транзакции `CLEARING`**:

   - создать запись в `transactions` с типом `CLEARING`, `state=NEW`;

   - `payload`:

     ```json
     {
       "equivalent": "E",
       "cycle": ["A", "B", "C", "A"],
       "amount": S
     }
     ```

3. **Согласие участников**:

   - режим авто‑согласия:
     - если политики trustlines и общие правила это позволяют (уменьшение долга считается априори благоприятным),
     - можно сразу переходить к фазе применения (2PC для долгов).
   - режим явного согласия:
     - отправка уведомлений (`CLEARING_PROPOSE`) участникам;
     - ожидание `CLEARING_ACCEPT/REJECT`;
     - при отказе хотя бы одного — `state=REJECTED`.

4. **Применение (`COMMIT`)**:

   - уменьшить `debt[Vi→V(i+1)]` на `S` для каждого ребра:
     - в транзакции БД;
     - с учётом идемпотентности (повторный `COMMIT` не меняет результат);
   - `state = COMMITTED`.

### 4.6. Reporting & Analytics

Функции:

- агрегированные показатели:
  - для каждого участника:
    - суммарный долг (`total_debt`),
    - суммарный кредит (`total_credit`),
    - `net_balance`,
    - суммарный входящий/исходящий доверие (`total_incoming_trust`, `total_outgoing_trust`).
- аналитические отчёты для координаторов сообщества:
  - у кого концентрация долгов;
  - какие связи мало используются;
  - показатели клиринга (сколько долгов «схлопнуто»).
- визуализации (опционально):
  - граф сети доверия;
  - тепловые карты долгов.

------

## 5. Data Layer: детализация

### 5.1. Основные таблицы PostgreSQL

(С учётом уже описанной логической модели; здесь — краткая структура.)

```sql
CREATE TABLE participants (
  id UUID PRIMARY KEY,
  public_key BYTEA NOT NULL,
  display_name TEXT,
  profile JSONB,
  status TEXT NOT NULL, -- 'active', ...
  created_at TIMESTAMPTZ NOT NULL,
  updated_at TIMESTAMPTZ NOT NULL
);

CREATE TABLE equivalents (
  id UUID PRIMARY KEY,
  code TEXT UNIQUE NOT NULL,
  precision INT NOT NULL,
  metadata JSONB,
  created_at TIMESTAMPTZ NOT NULL,
  updated_at TIMESTAMPTZ NOT NULL
);

CREATE TABLE trust_lines (
  id UUID PRIMARY KEY,
  from_participant_id UUID REFERENCES participants(id),
  to_participant_id UUID REFERENCES participants(id),
  equivalent_id UUID REFERENCES equivalents(id),
  limit NUMERIC NOT NULL,
  policy JSONB,
  status TEXT NOT NULL, -- 'active', 'frozen', 'closed'
  created_at TIMESTAMPTZ NOT NULL,
  updated_at TIMESTAMPTZ NOT NULL,
  UNIQUE (from_participant_id, to_participant_id, equivalent_id)
);

CREATE TABLE debts (
  id UUID PRIMARY KEY,
  debtor_id UUID REFERENCES participants(id),
  creditor_id UUID REFERENCES participants(id),
  equivalent_id UUID REFERENCES equivalents(id),
  amount NUMERIC NOT NULL CHECK (amount > 0),
  created_at TIMESTAMPTZ NOT NULL,
  updated_at TIMESTAMPTZ NOT NULL,
  UNIQUE (debtor_id, creditor_id, equivalent_id)
);

CREATE TABLE transactions (
  id UUID PRIMARY KEY, -- tx_id
  type TEXT NOT NULL,
  initiator_id UUID REFERENCES participants(id),
  payload JSONB NOT NULL,
  state TEXT NOT NULL,
  signatures JSONB,
  created_at TIMESTAMPTZ NOT NULL,
  updated_at TIMESTAMPTZ NOT NULL
);
```

При необходимости можно добавить:

- `transaction_participants (transaction_id, participant_id, role, signature)`.

### 5.2. Redis

Применение:

- сессии (auth, WebSocket);
- временные `prepare_locks`:
  - например, ключ `prepare:tx_id` → карта `edge_key → reserved_amount`;
  - `edge_key` = `(debtor, creditor, equivalent)`.
- очереди/шедулеры для задач ClearingEngine (если не использовать встроенный планировщик в приложении).

------

## 6. Клиентские приложения и UX

### 6.1. Web‑клиент (SPA/PWA)

Основные экраны:

1. **Дашборд**:
   - текущий net‑баланс;
   - входящие/исходящие trustlines;
   - ключевые индикаторы (сколько я должен, сколько должны мне).
2. **Линии доверия**:
   - список исходящих (я даю доверие) и входящих (мне доверяют);
   - форма создания/редактирования линии:
     - выбор участника;
     - эквивалент;
     - лимит;
   - подтверждение и подпись операции.
3. **Платёж**:
   - форма «Заплатить»:
     - выбор получателя;
     - сумма;
     - эквивалент;
   - просмотр результата:
     - подтверждение успеха/ошибки;
     - (опционально) визуализация маршрута.
4. **Клиринг**:
   - уведомления о предложенных клирингах;
   - кнопки «Согласен/Отказываюсь» (если не авто‑режим).
5. **История**:
   - список транзакций:
     - trustlines;
     - платежи;
     - клиринги;
   - фильтры и детали по каждой транзакции.

### 6.2. Управление ключами

- При первом входе (или при регистрации):
  - генерация пары Ed25519 через WebCrypto/JS‑библиотеку;
  - сохранение в защищённом хранилище (IndexedDB).
- Возможность:
  - экспортировать seed/приватный ключ для резервного копирования;
  - импортировать при смене устройства.
- Все подписи:
  - формируются на клиенте;
  - сервер получает только публичные ключи и подписи.

------

## 7. Потоки (flows) с учётом протокола

### 7.1. TrustLine: создание

1. A в UI задаёт B, эквивалент E, лимит L.
2. Клиент A:
   - формирует объект `TRUST_LINE_CREATE` (тип + payload + tx_id);
   - подписывает его `sig_A`;
   - отправляет на hub.
3. Hub:
   - проверяет подпись (по `public_key` A);
   - проверяет бизнес‑ограничения;
   - пишет в БД (`trust_lines`, `transactions`);
   - уведомляет B через WebSocket.

### 7.2. Платёж (happy‑path)

1. A в UI создаёт `PAYMENT_REQUEST` к B на сумму S в E.
2. Hub:
   - создаёт `transactions` запись (`state=NEW`);
   - обращается к RoutingService → получает `routes[]`;
   - обновляет транзакцию: `payload.routes`, `state=ROUTED`.
3. PaymentEngine:
   - запускает фазу PREPARE:
     - считает локальные эффекты;
     - проверяет лимиты и политики;
     - резервирует ресурсы (в Redis/БД);
   - если всё ок — переводит в `PREPARE_IN_PROGRESS` и затем в COMMIT:
     - обновляет `debts` по всем рёбрам;
     - снимает резервы;
     - `state=COMMITTED`.
   - при ошибке — освобождает резервы, `state=ABORTED`.
4. Клиент A (и B) видят результат через WebSocket/HTTP‑ответ.

### 7.3. Клиринг

1. После коммита платежа:
   - ClearingEngine сканирует локальный подграф;
   - находит цикл, например `A → B → C → A`;
   - определяет минимальный долг S по рёбрам цикла.
2. Создаёт `CLEARING` транзакцию:
   - `state=NEW`;
   - `payload = {equivalent, cycle, amount}`.
3. В зависимости от настроек:
   - либо сразу применяет (2PC над `debts` с авто‑согласием);
   - либо рассылает приглашения участникам и ждёт `ACCEPT/REJECT` → затем COMMIT/REJECT.

------

## 8. Безопасность, приватность, устойчивость

### 8.1. Безопасность

- TLS везде.
- Хранение паролей — bcrypt/argon2.
- CSRF/XSS защиты.
- Подписанные протокольные операции:
  - trustlines: обязательно;
  - клиринг (в режиме согласия): обязательно;
  - платежи: поэтапно делать обязательными для участия A (и, возможно, других).

### 8.2. Приватность

- Hub видит сетевую структуру и суммы.
- Никакие приватные ключи не попадают на сервер.
- Можно зашифровать описания сделок (комментарии) end‑to‑end между участниками, если это важно.

### 8.3. Устойчивость и восстановление

- Бэкапы PostgreSQL (полные + инкрементальные).
- Логирование транзакций и состояний.
- Идемпотентность `tx_id`:
  - повторные `COMMIT`/`ABORT` не меняют состояние;
  - позволяет безопасно повторять операции при сетевых сбоях.

------

### 9. Технологический стек (ревизия под Python‑экосистему и модульность)

Архитектура GEO‑узла должна быть:

- предельно читаемой для контрибьюторов;
- расширяемой через аддоны по принципу Home Assistant;
- удобной для генерации и сопровождения кода с помощью ИИ‑агентов.

Исходя из этого, выбираем следующий стек.

#### 9.1. Backend

- **Язык:** Python 3.11+
   Простота чтения, огромная экосистема, низкий порог входа для контрибьюторов.
- **Web‑фреймворк:** FastAPI
   Асинхронность «из коробки», декларативные модели запросов и ответов (через Pydantic), автогенерация OpenAPI‑спеки.
- **Модели и валидация:** Pydantic
   Чёткие типизированные модели, удобные как для людей, так и для ИИ‑агентов.
- **Доступ к БД:** SQLAlchemy 2.x + Alembic
   Надёжная ORM, поддержка PostgreSQL, миграции схемы БД.
- **База данных:** PostgreSQL
   Основное хранилище состояния (participants, trustlines, debts, transactions).
- **Кэш и очереди:** Redis
   Кэширование, временные prepare‑локи для фаз платежей, фоновая обработка задач (через RQ/Celery/Arq).
- **Тестирование:** pytest
   Простой и де‑факто стандартный тестовый фреймворк в Python‑мире.
- **Контейнеризация:** Docker, docker‑compose; далее — Kubernetes при масштабировании
   Для развёртывания узлов в разных сообществах и окружениях.
- **Архитектура аддонов:**
   Ядро GEO реализует основную доменную модель и протокол. Расширения подключаются как отдельные Python‑пакеты (аддоны) через механизм `entry_points`. Аддоны могут:
  - регистрировать свои HTTP/WebSocket‑эндпоинты;
  - подписываться на внутренние события (например, «PAYMENT.COMMITTED»);
  - добавлять задачи в планировщик (периодические проверки, расширенные отчёты и т.п.).

#### 9.2. Клиентские приложения

Пользовательский опыт выносится в кроссплатформенное нативное приложение, а web‑часть используется в основном для админки и диагностики.

- **Основной клиент (мобильный/десктоп/web):** Flutter
   Единый код на Dart для Android, iOS, десктопа и, при необходимости, web‑версии. Богатая библиотека готовых компонентов, чёткая структура UI‑модулей. Удобен для генерации и доработки кода с помощью ИИ‑агентов.
- **Архитектура клиента:**
   Основное приложение GEO‑клиента и модули/виджеты по доменам (trustlines, payments, clearing, отчёты), которые можно подключать и дорабатывать независимо.
- **Минимальный web‑интерфейс узла (админка):**
   Сервер‑рендеринг HTML (Jinja2) на стороне backend’а + минимальный JS для интерактивности (HTMX/Alpine.js). Такой подход избегает тяжёлых SPA‑фреймворков, оставаясь при этом удобным для разработчиков и ИИ‑агентов.

------

## 10. Эволюция архитектуры

### 10.1. Кластеризация hub’а

- Несколько инстансов backend’а за балансировщиком.
- Репликация PostgreSQL (master/replica).
- В перспективе — консенсусный журнал транзакций (Raft/Tendermint).

### 10.2. Межсообществовой уровень

- Каждый hub имеет PID и trustlines с другими hub’ами.
- Платежи и клиринг между участниками разных сообществ:
  - те же транзакции `PAYMENT`/`CLEARING`;
  - маршруты включают hub’ы.
- Нужно только:
  - расширить routing до мульти‑hub’ового графа;
  - реализовать транспорт между hub’ами (WebSocket/gRPC).

### 10.3. Частичный p2p

- Крупные участники могут запускать свои ноды:
  - хранить свои trustlines и долги локально;
  - участвовать в 2PC напрямую;
  - hub — больше координатор/индексатор.
- Протокол GEO v0.1 уже предусматривает такую возможность:
  - те же сообщения/состояния, другой транспорт.