## GEO v0.1 — базовый протокол кредитной сети для локальных сообществ и кластеров

*Этот документ доработан с учётом идей из оригинального GEO Protocol, но остаётся максимально простым и пригодным для MVP на архитектуре community‑hub.*

------

## 0. Назначение протокола

**GEO v0.1** — это протокол:

- p2p‑экономики взаимного кредита:
  - между отдельными участниками (люди, организации);
  - между сообществами (их хабы выступают как обычные участники);
- без единой валюты и без глобального леджера:
  - только **обязательства** между участниками и **линии доверия** (лимиты риска);
- с:
  - простыми и проверенными алгоритмами (BFS, 2PC, поиск коротких циклов);
  - ясной моделью сообщений и состояний транзакций;
  - возможностью эволюции к p2p и кластерным хабам.

------

## 1. Модель сущностей протокола

### 1.1. Участник (Participant)

**Participant ID (PID)**:

- крипто‑идентичность участника:
  - пара ключей Ed25519 (`public_key`, `secret_key`);
  - `PID = base58(sha256(public_key))` (конкретный формат фиксируется реализацией).
- любые сущности в протоколе ссылаются на участников по `PID`.

**Роли (логические):**

- конечный пользователь (человек, бизнес);
- community‑hub (сервер сообщества);
- агрегатор/шлюз (для фиата/крипты, позже).

**Принцип локальности:**

- Линия доверия `A → B` — **собственность A**;
- Долги `X→Y` — часть криптографически подтверждаемого состояния X и Y (подписи на транзакциях).

### 1.2. Эквивалент (Equivalent)

Единица счёта:

- `code`: строковый код (`"UAH"`, `"HOUR_DEV"`, `"kWh"`, ...);
- `precision`: количество знаков после запятой;
- `metadata`: описание.

Все trustlines и долги **всегда** указывают эквивалент. Нет «валюты по умолчанию».

### 1.3. Линия доверия (TrustLine)

TrustLine (TL):

- `from`: `PID_from` — кто **даёт доверие**;
- `to`: `PID_to` — кому доверяют;
- `equivalent`: `E`;
- `limit`: максимальный объём, на который `to` может быть должен `from` в `E`;
- `policy` (опционально):
  - авто‑согласие на клиринг;
  - ограничения на использование как посредника;
  - предел суточных движений и т.п.

Семантика:

- в любой момент: (debt[to \to from, E] \le limit).

Создание/изменение trustline — операция, **подписанная `from`**.

### 1.4. Обязательство (Debt / Obligation)

Ребро долга:

- `debtor`: PID_X;
- `creditor`: PID_Y;
- `equivalent`: E;
- `amount`: число > 0.

Семантика:

- X должен Y `amount` в эквиваленте E.

Для каждой пары `(X,Y,E)` допускается одно агрегированное ребро `debt[X→Y,E]` (протокол не навязывает хранения «каждой сделки» — это уровень приложения).

Связь с TrustLine:

- для рёбер вида `B→A` должно выполняться:
  - `debt[B→A, E] ≤ limit(A→B,E)`.

### 1.5. Транзакция (Transaction)

Любое изменение состояния (`trustlines`, `debt`) — результат транзакции.

Общие поля:

- `tx_id`: глобальный идентификатор (можно `hash(payload)` или UUID);
- `type`:
  - `TRUST_LINE_CREATE | TRUST_LINE_UPDATE | TRUST_LINE_CLOSE`;
  - `PAYMENT`;
  - `CLEARING`.
- `initiator`: PID;
- `payload`: типизированный объект (см. ниже);
- `signatures`: подписи участвующих сторон (см. далее);
- `timestamp`: момент создания/инициации.

### 1.6. Состояние транзакции (State machine)

Для ясности и совместимости с возможным p2p‑режимом вводятся **простые стейт‑машины**.

**Для `PAYMENT`:**

Состояния:

- `NEW` — запрос платёжа сформирован (инициатор → координатор);
- `ROUTED` — найдены маршруты (пути, суммы по ним);
- `PREPARE_IN_PROGRESS` — рассылаются `PREPARE`, ждём `ACK`;
- `COMMITTED` — все участники применили изменения;
- `ABORTED` — транзакция отменена (ошибка маршрутизации или отказ/таймаут `PREPARE`).

**Для `CLEARING`:**

- `NEW` — кандидат цикла найден;
- `PROPOSED` — отправлены предложения участникам (если нужно явное согласие);
- `WAITING_CONFIRMATIONS` — ожидание ответов;
- `COMMITTED` — клиринг применён;
- `REJECTED` — хотя бы один участник отказался/не ответил.

Переходы между состояниями фиксируются в локальном журнале координатора (хаба/узла) и могут быть восстановлены при сбоях.

------

## 2. Операции протокола

### 2.1. Управление линиями доверия

#### 2.1.1. TRUST_LINE_CREATE / UPDATE

**Сообщение (на уровне протокола):**

```json
{
  "msg_type": "TRUST_LINE_CREATE", // или UPDATE
  "tx_id": "…",
  "from": "PID_A",
  "payload": {
    "from": "PID_A",
    "to": "PID_B",
    "equivalent": "UAH",
    "limit": 100.0,
    "policy": { /* optional */ }
  },
  "signature": "sig_A"
}
```

Требования:

- подпись `signature` = `Sign_A(msg_type, tx_id, payload, ...)`;
- координатор (хаб или узел) проверяет подпись и применяет изменения.

Алгоритм применения:

1. Проверить подпись A.
2. Проверить допустимость лимита (локальные правила).
3. Создать или обновить TrustLine.
4. Создать транзакцию `TRUST_LINE_CREATE/UPDATE (COMMITTED)` в своём журнале.

#### 2.1.2. TRUST_LINE_CLOSE

Аналогично, но:

- может потребовать, чтобы все долги `debt[B→A,E]` были погашены (или переведены/клированы);
- иначе — отклонение.

------

### 2.2. Платёж (PAYMENT)

#### 2.2.1. PAYMENT_REQUEST (к координатору)

Это не транзакция протокола, а прикладной запрос (обычно по HTTP/WS) к ближайшему координатору (community‑hub).

```json
{
  "msg_type": "PAYMENT_REQUEST",
  "from": "PID_A",
  "payload": {
    "to": "PID_B",
    "equivalent": "UAH",
    "amount": 60.0,
    "constraints": {
      "max_hops": 4,
      "avoid": ["PID_XYZ"]
    }
  },
  "signature": "sig_A" // опционально в MVP
}
```

Координатор:

- валидирует запрос;
- инициирует внутренний `PAYMENT` (создаёт `tx_id`, состояние `NEW`).

#### 2.2.2. Routing (RoutingService)

**Задача:** на основе настоящего состояния сети доверия найти 1–3 пути от A к B.

Для каждого ориентированного ребра (A→B,E):

[ available_credit(A \to B, E) = limit(A \to B, E) - debt[B \to A, E] ]

Условия для ребра:

- `available_credit > 0`.

Алгоритм light‑multi‑path:

1. Найти первый путь `P1` с BFS (ограничение длины `max_hops`).
2. Вычислить `c1 = capacity(P1) = min(available_credit(e) по e ∈ P1)`.
3. Если `c1 ≥ S` — ок, одного пути достаточно.
4. Если `c1 < S`:
   - временно «вычесть» `c1` из `available_credit` по рёбрам `P1`;
   - найти второй путь `P2`, не использующий исчерпанные рёбра;
   - посчитать `c2`.
   - если `c1 + c2 ≥ S` — разбить платёж:
     - `amount_1 = min(c1, S)`,
     - `amount_2 = S - amount_1`.
5. Аналогично можно добавить 3‑ий путь (по желанию), но лучше ограничиться двумя в v0.1.

Результат — **набор маршрутов**:

```json
"routes": [
  {
    "path": ["A", "X1", "B"],
    "amount": 40.0
  },
  {
    "path": ["A", "Y1", "Y2", "B"],
    "amount": 20.0
  }
]
```

Координатор переводит транзакцию в состояние `ROUTED`.

#### 2.2.3. Транзакция PAYMENT

Норма протокола:

```json
{
  "tx_id": "…",
  "type": "PAYMENT",
  "initiator": "PID_A",
  "payload": {
    "from": "PID_A",
    "to": "PID_B",
    "equivalent": "UAH",
    "total_amount": 60.0,
    "routes": [
      { "path": ["A", "X1", "B"], "amount": 40.0 },
      { "path": ["A", "Y1", "Y2", "B"], "amount": 20.0 }
    ]
  },
  "signatures": {
    "from": "sig_A" // в продвинутом варианте может быть обязательно
  }
}
```

#### 2.2.4. Исполнение платежа (PaymentEngine, 2PC)

**Фаза 1. PREPARE**

Для каждого участника, затронутого транзакцией (кроме координатора), координатор формирует сообщение `PAYMENT_PREPARE`:

```json
{
  "msg_type": "PAYMENT_PREPARE",
  "tx_id": "…",
  "from": "COORDINATOR_PID",
  "to": "PID_X",
  "payload": {
    "equivalent": "UAH",
    "local_effects": [
      {
        "debtor": "PID_X",
        "creditor": "PID_Y",
        "delta": +10.0
      },
      ...
    ]
  },
  "signature": "sig_COORD"
}
```

Узел/хаб X:

1. Проверяет, что каждая `delta`:

   - не приводит к `debt[...]` > `limit` по соответствующим TrustLines;
   - не нарушает его локальные политики (по `policy` trustlines, максимумам и т.п.).

2. Если всё ок:

   - **резервирует** ресурсы (помечает в локальном состоянии, что эти лимиты заняты);

   - отвечает `PAYMENT_PREPARE_ACK`:

     ```json
     {
       "msg_type": "PAYMENT_PREPARE_ACK",
       "tx_id": "…",
       "from": "PID_X",
       "payload": { "status": "OK" },
       "signature": "sig_X"
     }
     ```

3. Если нет:

   - `status = "FAIL"` (и причина).

Координатор ждёт все `ACK` → состояние транзакции:

- если все `OK` → `PREPARE_IN_PROGRESS`;
- если кто‑то `FAIL` → сразу `ABORTED`.

**Фаза 2. COMMIT / ABORT**

Если `PREPARE` успешен:

- координатор рассылает `PAYMENT_COMMIT`:

  ```json
  {
    "msg_type": "PAYMENT_COMMIT",
    "tx_id": "…",
    "from": "COORDINATOR_PID",
    "to": "PID_X",
    "signature": "sig_COORD"
  }
  ```

- каждый участник:

  - снимает резервы,
  - фактически обновляет долги `debt[...]` согласно `local_effects`,
  - помечает локально транзакцию `COMMITTED`.

Если `PREPARE` не прошёл:

- `PAYMENT_ABORT` рассылается вместо `COMMIT`,
- участники снимают резервы без изменений в долгах.

**Идемпотентность:**

- Повторные `COMMIT` по тому же `tx_id` не должны менять состояние больше одного раза (узел хранит состояние транзакции локально).

------

### 2.3. Клиринг (CLEARING)

#### 2.3.1. Поиск циклов (ClearingEngine)

**Локально‑триггерный подход:**

- После каждой `PAYMENT.COMMITTED`:
  - берём все рёбра долгов, которые изменились;
  - рассматриваем их как «центр» для поиска коротких циклов в радиусе 2–3 шагов.

Ищем:

- циклы длиной 3:
  - `A → B → C → A` (по положительным `debt`).
- циклы длиной 4:
  - `A → B → C → D → A`.

Для каждого цикла (C = (V0, V1, ..., V(k-1), V0)):

[ S = \min(debt[Vi \to V(i+1)]) ]

Если (S > \epsilon) (порог, например, `0.01`), можно сформировать кандидат:

- `CLEARING` на сумму S.

Периодически можно делать более широкий поиск (cron) по всей сети, но базово достаточно локального.

#### 2.3.2. Транзакция CLEARING

```json
{
  "tx_id": "…",
  "type": "CLEARING",
  "initiator": "COORDINATOR_PID",
  "payload": {
    "equivalent": "UAH",
    "cycle": ["A", "B", "C", "A"],
    "amount": 15.0
  },
  "signatures": {
    "initiator": "sig_COORD"
  }
}
```

**Эффект:**
 для каждой дуги `Vi → V(i+1)`:

- `debt[Vi→V(i+1),E] -= amount`.

#### 2.3.3. Подтверждение клиринга

Два режима (настраиваются политиками участвующих trustlines/узлов):

1. **Авто‑согласие по умолчанию**:
   - если trustline `X→Y` не запрещает авто‑клиринг,
   - и уменьшение `debt` всегда «улучшает» позицию участника,
   - координатор может считать согласие **по умолчанию**;
   - всё равно может послать уведомление `CLEARING_NOTICE`.
2. **Явное согласие**:
   - координатор рассылает `CLEARING_PROPOSE` участникам цикла;
   - они отвечают `CLEARING_ACCEPT`/`REJECT`;
   - если все `ACCEPT` — запускается 2PC (`PREPARE`/`COMMIT`) с уменьшением долгов по рёбрам;
   - если кто‑то `REJECT` — `REJECTED`.

Внутренне для применения изменений можно использовать тот же 2PC‑механизм, что и для `PAYMENT`.

------

## 3. Межсообществовой обмен (хабы как участники)

Каждый **community‑hub**:

- имеет собственный `PID`;
- может открывать trustlines с другими хабами:
  - `Hub1 → Hub2 (limit=L, E)`.

Платёж `A@Hub1 → B@Hub2` логически:

- `A → ... → Hub1 → Hub2 → ... → B`.

Координатором может быть:

- Hub1 (по умолчанию, если `from` там);
- или отдельный согласованный механизм (позже).

Протокол **точно такой же**:

- `PAYMENT_REQUEST` → маршрутизация с участием хабов;
- 2PC по всем участникам цепочки (включая хабы);
- `CLEARING` между хабами — на основе накопленных долгов `debt[Hub1→Hub2, E]` и `debt[Hub2→Hub1, E]`.

Отдельный «межхабовый» протокол не нужен в v0.1 — мы используем те же операции.

------

## 4. Протокольные сообщения и транспорт

### 4.1. Типы протокольных сообщений

- Конфигурация/состояние:
  - `TRUST_LINE_CREATE`, `TRUST_LINE_UPDATE`, `TRUST_LINE_CLOSE`.
- Платежи:
  - `PAYMENT_REQUEST` (к координатору, чаще всего HTTP/WS, может не быть частью «чистого протокола»);
  - `PAYMENT_PREPARE`, `PAYMENT_PREPARE_ACK`;
  - `PAYMENT_COMMIT`, `PAYMENT_ABORT`.
- Клиринг:
  - `CLEARING_PROPOSE`, `CLEARING_ACCEPT`, `CLEARING_REJECT`;
  - `CLEARING_PREPARE` (если используем 2PC для применения);
  - `CLEARING_COMMIT`, `CLEARING_ABORT`.

Все сообщения имеют общий базовый формат:

```json
{
  "msg_id": "UUID",
  "msg_type": "STRING",
  "tx_id": "UUID or null",
  "from": "PID",
  "to": "PID or HUB or null",
  "payload": { ... },
  "signature": "BASE64(ed25519_signature)" // от 'from'
}
```

### 4.2. Транспорт

- Внутри community‑hub:
  - сообщения могут реализовываться как вызовы сервисов + записи в БД (REST/WS поверх JSON для клиентов).
- Между хабами / p2p:
  - те же типы сообщений могут идти:
    - по WebSocket,
    - по gRPC,
    - по любому надёжному или полунадёжному каналу.

Важное требование:

- **формат и семантика сообщений независимы от транспорта**, чтобы можно было добавлять:
  - p2p‑уровень, не меняя «язык протокола».

------

## 5. Идемпотентность и обработка сбоев

- `tx_id` уникален в пределах координатора:
  - повторные `COMMIT` по уже `COMMITTED` транзакции **ничего не меняют**;
  - повторные `PREPARE` при уже `COMMITTED/ABORTED` должны получать ответ в соответствии с финальным состоянием.

Рекомендации:

- хранить локально у каждого узла:
  - таблицу `transactions_local_state`:
    - `tx_id`,
    - `state` (`NEW`, `PREPARE_OK`, `COMMITTED`, `ABORTED`, ...),
    - `last_update`.

При сетевых сбоях:

- координатор может повторно отправить `PREPARE`/`COMMIT`;
- участник, увидев уже обработанный `tx_id`, просто возвращает устойчивый ответ.

------

## 6. Расширяемость (куда дальше)

Протокол v0.1 сохраняет:

- **простоту** реализации для community‑hub;
- и в то же время:
  - позволяет:
    - усложнять routing (k‑shortest paths, max‑flow),
    - переносить координацию на p2p‑уровень (когда участники будут иметь полноценные ноды),
    - вводить кластеры хабов с консенсусом над журналом транзакций,
    - интегрироваться с блокчейнами (через отдельные типы Participants и эквивалентов).

------

